<?xml version="1.0" encoding="utf-8"?>
<html lang="fr">
  <head>
    <title>Exemple</title>
    <meta name="teaching-assistant-code-style" content="dracula"/>
    <meta name="teaching-assistant-generator" content="moodle-player"/>
    <!--        uncomment to add slide-->
    <!--                <meta name="teaching-assistant-generator" content="moodle-slides"/>-->
    <meta name="teaching-assistant-menu-level" content="3"/>
    <meta name="teaching-assistant-version" content="2.8.0"/>
    <meta name="teaching-assistant-course-datetime" content="2023-02-14 10:47:33"/>
  </head>
  <body>
    <section>
      <h1>Installation</h1>
      <article>
        <h2>Android Studio</h2>
        <p>
          Télécharger directement depuis le site d'Android développeur
                    
          <a href="https://developer.android.com/studio">Android Studio</a>
        </p>
        <p>
          Si vous avez besoin de plus d'information pour d'autre Système d'exploitation
                    
          <a href="https://developer.android.com/studio/install">Guide Installation</a>
        </p>
      </article>
      <article>
        <h2>Installation de l'émulateur</h2>
        <p>Pour pouvoir tester l'application, on va devoir installer un émulateur. Dans Android Studio il y a
                    déjà une solution de présente pour cela
                </p>
        <ul>
          <li>
            Créer un device virtuel
                        
            <a href="https://developer.android.com/studio/run/managing-avds">Virtual
                            Device
                        </a>
          </li>
          <li>
            Utiliser un outil externe
                        
            <ul>
              <li>
                <a href="https://www.memuplay.com/">Menu Play</a>
              </li>
              <li>
                <a href="https://www.bluestacks.com/fr/index.html">Blue Stack</a>
                
                                PC et Mac seulement
                            
              </li>
            </ul>
          </li>
        </ul>
      </article>
      <article>
        <h2>Configurer le Téléphone</h2>
        <p>
          Lors de la création d'une application Android, il est important de toujours tester votre application
                    sur un appareil réel avant de la diffuser aux utilisateurs. Pour pouvoir déployer votre application
                    sur un téléphone vous allez devoir suivre plusieurs étapes.
                    
          <a href="https://developer.android.com/studio/run/device">DOC</a>
        </p>
        <ul>
          <li>
            Activer le mode développeur
                        
            <a href="https://developer.android.com/studio/debug/dev-options">DOC</a>
          </li>
          <li>Activer le développeur option</li>
          <li>Activer le débogage USB</li>
        </ul>
      </article>
      <article>
        <h2>Documentation</h2>
        <p>
          Android évolue vite, il faut constamment aller voir sur la documentation officiel les changements.
                    
          <a href="https://developer.android.com/docs">Documentation Officiel</a>
        </p>
        <p>La documentation est subdivisée en plusieurs parties :</p>
        <img class="img-fluid rounded" src="../asset/documentation.png" alt="Description alternative"/>
        <ul>
          <li>
            <a href="https://developer.android.com/guide">Le guide</a>
            
                        comme un tutoriel avec des examples de comment ça fonctionne.
                    
          </li>
          <li>
            <a href="https://developer.android.com/reference">La Référence</a>
            
                        le manuel pour chaque classe d'Android avec la liste et la description des constructeurs, des
                        méthodes et des attributs
                    
          </li>
          <li>
            Un guide pour les interfaces
                        
            <ul>
              <li>
                <a href="https://developer.android.com/develop/ui">UI guide</a>
              </li>
              <li>
                <a href="https://developer.android.com/design">Design guide</a>
              </li>
            </ul>
          </li>
        </ul>
      </article>
      <article>
        <h2>Miroir</h2>
        <p>Une fonctionnalité intéressante lors d'une présentation est de pouvoir faire le miroir du téléphone
                    et l'afficher sur un écran. Voici deux applications qui le font:
                </p>
        <ul>
          <li>
            
                        L'extension de chrome
                        
            <a href="https://chrome.google.com/webstore/detail/vysor/gidgenkbbabolejbgbpnhbimgjbffefm">
                            Vysor
                        </a>
            
                        permet de rapidement faire un miroir du téléphone
                    
          </li>
          <li>
            <a href="https://github.com/Genymobile/scrcpy">Screen Copy</a>
            
                        projet open-source avec pleins d'options intéressantes, mais un peu plus de configuration à
                        faire.
                    
          </li>
        </ul>
      </article>
    </section>
    <section>
      <h1>Introduction</h1>
      <article>
        <h2>
          Architecture Système Android
            
          <a href="https://developer.android.com/guide/platform">DOC</a>
        </h2>
        <p>Android est un système open source basé sur un noyau Linux créer pour un large éventail d'appareils</p>
        <ul>
          <li>Appareils tactiles : Smartphone, tablette, montre</li>
          <li>Autre : Téléviseur, autoradio, voiture ...</li>
        </ul>
        <img class="img-fluid rounded" src="../asset/android_architecture.png" alt="Description alternative"/>
      </article>
      <article>
        <h3>Le noyaux linux</h3>
        <p>La base de la plate-forme Android est le noyau Linux. Par exemple, Android Runtime (ART) s'appuie sur le
            noyau Linux pour les fonctionnalités sous-jacentes telles que le threading et la gestion de la mémoire de
            bas niveau.
        </p>
        <p>L'utilisation d'un noyau Linux permet à Android de tirer parti des principales fonctionnalités de sécurité et
            permet aux fabricants d'appareils de développer des pilotes matériels pour un noyau bien connu.
        </p>
      </article>
      <article>
        <h3>Couche d'abstraction matérielle (HAL)</h3>
        <p>La couche d'abstraction matérielle (HAL) fournit des interfaces standard qui exposent les capacités
            matérielles de l'appareil au cadre d'API Java de niveau supérieur. Le HAL se compose de plusieurs modules de
            bibliothèque, chacun implémentant une interface pour un type spécifique de composant matériel, tel que la
            caméra ou le module Bluetooth. Lorsqu'une API d'infrastructure effectue un appel pour accéder au matériel de
            l'appareil, le système Android charge le module de bibliothèque pour ce composant matériel.
        </p>
      </article>
      <article>
        <h3>Android Runtime</h3>
        <p>Pour les appareils exécutant Android version 5.0 (niveau API 21) ou supérieur, chaque application s'exécute
            dans son propre processus et avec sa propre instance d'Android Runtime (ART). ART est écrit pour exécuter
            plusieurs machines virtuelles sur des appareils à faible mémoire en exécutant des fichiers DEX, un format de
            bytecode conçu spécialement pour Android et optimisé pour une empreinte mémoire minimale. Anciennement on
            utilisait la DVM ou Dalvik Virtual Machine pour gérer les applications.
        </p>
      </article>
      <article>
        <h3>Bibliothèques C/C++ natives</h3>
        <p>De nombreux composants et services principaux du système Android sont construits à
            partir des bibliothèques natives écrites en C et C++.
            La plate-forme Android fournit des API de framework Java pour exposer les fonctionnalités de certaines de
            ces bibliothèques natives aux applications.
        </p>
        <p>Si vous développez une application qui nécessite du code C ou C++, vous pouvez utiliser le NDK Android pour
            accéder à certaines de ces bibliothèques de plate-forme natives directement à partir de votre code natif.
        </p>
      </article>
      <article>
        <h3>Java API Framework</h3>
        <p>L'ensemble des fonctionnalités du système d'exploitation Android est à votre disposition via des API écrites
            en langage Java. Ces API constituent les blocs de construction dont vous avez besoin pour créer des
            applications Android en simplifiant la réutilisation des composants et services système modulaires de base,.
        </p>
      </article>
      <article>
        <h3>Applications système</h3>
        <p>Android est livré avec un ensemble d'applications de base pour la messagerie électronique, la messagerie SMS,
            les calendriers, la navigation sur Internet, les contacts, etc. Les applications incluses avec la
            plate-forme n'ont aucun statut particulier parmi les applications que l'utilisateur choisit d'installer.
            Ainsi, une application tierce peut devenir le navigateur Web par défaut de l'utilisateur.
        </p>
      </article>
      <article>
        <h3>Puissance téléphone</h3>
        <p>Même si les téléphone deviennent de plus en plus puissant, ne pas oublier qu'ils sont beaucoup moins
            puissants qu'un ordinateur. Une phase d'optimisation de l'application pourrait s'avérer nécessaire.
        </p>
      </article>
      <article>
        <h2>Historique</h2>
        <p>Google pas créateur d'Android !!</p>
        <p>Origine Android est Android Incorporated racheté par Google en 2005</p>
        <p>2007 l'Open Handset Alliance 35 entreprises évoluant dans l'univers du mobile avec un OS OpenSource
        </p>
      </article>
      <article>
        <h2>Langage</h2>
        <p>Les applications Android peuvent être écrites à l'aide des langages Kotlin, Java et C++. Les outils Android
            SDK compilent votre code avec tous les fichiers de données et de ressources dans un APK ou un Android App
            Bundle.
        </p>
        <p>Dans le cadre du cours, on utilisera Java pour éviter d'avoir à apprendre un nouveau langage.</p>
        <p>Dans la documentation Google veut pousser l'utilisation de Kotlin</p>
      </article>
      <article>
        <h2>ART - Dalvik</h2>
        <p>
          <a href="https://source.android.com/docs/core/runtime">ART</a>
          
            ou Android Runtime anciennement DVM ou Dalvik Virtual Machine
        
        </p>
      </article>
      <article>
        <h2>Hello World</h2>
        <p>Création de la première application avec Android Studio et déploiement dans l'émulateur ou le téléphone</p>
      </article>
    </section>
    <section>
      <h1>Architecture</h1>
      <p>Une application android est composée de trois parties</p>
      <ul>
        <li>Les Composants de base</li>
        <li>Les ressources de l'application</li>
        <li>Les fichiers de configuration</li>
      </ul>
      <article>
        <h2>Structure d'un projet android</h2>
        <pre><![CDATA[
                        MyApplication
                        ├── app
                        │   ├── libs
                        │   └── src
                        │   ├── androidTest
                        │   ├── main
                        │   │   ├── java  <--
                        │   │   ├── res   <--
                        │   │   └── AndroidManifest.xml  <--
                        │   └── test
                        ├── build.gradle  <--
                        └── gradlew
                ]]></pre>
        <ul>
          <li>java : répertoire avec toutes les classes et le code Java</li>
          <li>res : répertoire avec tous les fichiers supplémentaires, le contenu statique utilisés par votre
                code, tels que les bitmaps, les définitions de mise en page, les textes d'interface utilisateur, les
                instructions d'animation, etc...
            </li>
          <li>AndroidManifest.xml : fichier de configuration du projet</li>
          <li>build.gradle : configuration pour gradle</li>
        </ul>
      </article>
      <article>
        <h2>Les Composants de base</h2>
        <p>Il existe 4 types de composants possibles dans une application Android :</p>
        <ul>
          <li>Les Activities</li>
          <li>Les Services</li>
          <li>Les Brodcast Receivers</li>
          <li>Les Contents Providers</li>
        </ul>
        <p>
          On peut aussi parler d'un 5ᵉ objet
            
          <kbd>Intent</kbd>
          <a href="https://developer.android.com/guide/components/fundamentals#ActivatingComponents">DOC</a>
          
            qui sert
            à faire la liaison entre les 3 premiers. Dans la doc, on le qualifie de messager asynchrone.
        
        </p>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/guide/components/activities/intro-activities">Activity</a>
        </h3>
        <p>Une activité est le point d'entrée pour interagir avec l'utilisateur. Il représente un écran unique avec une
            interface utilisateur.
        </p>
        <p>En tant que telle, une application différente peut démarrer l'une de ces activités si l'application de
            messagerie le permet. Par exemple, une application d'appareil photo peut démarrer l'activité dans
            l'application de messagerie qui compose un
            nouveau courrier pour permettre à l'utilisateur de partager une image.
        </p>
        <p>Une activité facilite les interactions clés suivantes entre le système et l'application.
        </p>
        <p>On reviendra en détail sur ce composant dans la suite du cours.</p>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/guide/components/services">Services</a>
        </h3>
        <p>Un service est un point d'entrée à usage général pour maintenir une application en arrière-plan un peu comme
            un thread.
        </p>
        <p>Il s'agit d'un composant qui s'exécute en arrière-plan pour effectuer des opérations de longue durée ou pour
            effectuer des tâches pour des processus distants.
            Un service ne fournit pas d'interface utilisateur.
        </p>
        <ul>
          <li>Musique en arrière plan</li>
          <li>Récupérer des données sur le réseau sans bloquer l'interaction avec les activity</li>
        </ul>
        <p>Peut être démarré par une Activity et continuer de s'exécuter en arrière plan</p>
        <p>Il existe deux types de services qui indiquent au système comment gérer une application:</p>
        <ul>
          <li>Les services démarrés (started services)</li>
          <li>Les services liés. (bound services)</li>
        </ul>
        <p>Si on a le temps, on traitera les services dans le cours, mais pas évaluer dans le cours.</p>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/reference/android/content/BroadcastReceiver">Broadcast receivers</a>
        </h3>
        <p>Composant qui permet au système de transmettre des événements à l'application en dehors d'un flux
            d'utilisateurs régulier
        </p>
        <p>Permet à l'application de répondre aux annonces de diffusion à l'échelle du système</p>
        <ul>
          <li>Définir une alarme</li>
          <li>Publier une notification</li>
          <li>Niveau de la batterie (Quand elle est faible)</li>
        </ul>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/guide/topics/providers/content-providers">Les Contents Providers</a>
        </h3>
        <p>Pour gérer un ensemble de données dans le système de fichiers, dans une base de données SQLite, sur le Web ou
            sur tout autre emplacement de stockage persistant auquel votre application peut accéder.
        </p>
        <p>Pour le système, content provider est un point d'entrée dans une application pour accéder à des données
            nommées, identifiés par un schéma d'URI.
        </p>
      </article>
      <article>
        <h2>
          <a href="https://developer.android.com/guide/topics/resources/providing-resources">Les ressources</a>
        </h2>
        <p>Dans ce répertoire se trouve les ressources que vous allez utiliser dans votre application.</p>
        <p>Les ressources sont regroupées par type dans un sous répertoire correspondant :</p>
        <pre><![CDATA[
                Répertorie ressource commun :
                main
                ├── java
                └── res
                   ├── drawable
                   ├── layout
                   ├── mipmap
                   └── values
            ]]></pre>
        <p>
          Vous pouvez avoir la liste de tous les sous type 
          <a href="https://developer.android.com/guide/topics/resources/available-resources">ICI
        </a>
           mais pour le moment on va décrire les plus communes.
        
        </p>
        <ul>
          <li>drawable : Fichiers bitmap (.png, .jpg, .gif) ou XML.</li>
          <li>layout : Fichiers XML qui définissent la mise en page d'une interface utilisateur</li>
          <li>values : Fichiers XML contenant des valeurs simples, telles que des chaînes, des entiers et des
                couleurs.
            </li>
        </ul>
        <p>
          Dans le répertoire 
          <kbd>res/value</kbd>
           on pourra avoir :
        
        </p>
        <ul>
          <li>des couleurs</li>
          <li>des chaines de caractère</li>
          <li>des tableaux(int, string ...)</li>
          <li>des styles</li>
        </ul>
        <p>On peut faire plusieurs fichiers pour séparer les ressources et s'y retrouver plus facilement.</p>
        <p>Il en existe d'autres sous types, mais on les verra au fur et à mesure des besoins.</p>
        <p>On reviendra plus tard su comment accéder et utiliser les ressources.</p>
      </article>
      <article>
        <h2>Les fichiers de configurations</h2>
        <p>Le système de build Android compile les ressources et le code source de l'application et les regroupe dans
            des APK(Application PacKage) ou des bundles d'applications Android(AAB) que vous pouvez tester, déployer,
            signer et distribuer.
        </p>
        <p>Android Studio utilise Gradle, pour automatiser et gérer le processus de construction tout en vous permettant
            de définir des configurations de construction flexibles et personnalisées.
        </p>
        <p>Chaque projet d'application doit avoir un fichier AndroidManifest.xml (portant précisément ce nom) à la
            racine de l'ensemble source du projet. Le fichier manifeste décrit les informations essentielles sur votre
            application pour les outils de génération Android, le système d'exploitation Android et Google Play. On va
            avoir dans ce fichier:
        </p>
      </article>
      <article>
        <h3>
          AndroidManifest.xml
            
          <a href="https://developer.android.com/guide/topics/manifest/manifest-intro">DOC</a>
        </h3>
        <pre>
          <code class="xml"><![CDATA[
                    <?xml version="1.0" encoding="utf-8"?>
                    <manifest
                        xmlns:android="http://schemas.android.com/apk/res/android"
                        android:versionCode="1"
                        android:versionName="1.0">
                    
                        <uses-feature android:name="android.hardware.sensor.compass"
                            android:required="true" />
                    
                        <application
                            android:allowBackup="true"
                            android:icon="@mipmap/ic_launcher"
                            android:roundIcon="@mipmap/ic_launcher_round"
                            android:label="@string/app_name"
                            android:supportsRtl="true"
                            android:theme="@style/AppTheme">
                    
                            <activity android:name=".MainActivity">
                                <intent-filter>
                                    <action android:name="android.intent.action.MAIN" />
                                    <category android:name="android.intent.category.LAUNCHER" />
                                </intent-filter>
                            </activity>
                            <activity
                                android:name=".DisplayMessageActivity"
                                android:parentActivityName=".MainActivity" />
                        </application>
                    </manifest>
            ]]></code>
        </pre>
        <p>On va retrouver dans ce fichier :</p>
        <ul>
          <li>android:label -&gt; le nom de l'application</li>
          <li>android:icon -&gt; l'icon de l'application visible dans le téléphone</li>
          <li>La liste des différents composants (Activity, Service, Brodcast Receiver, Content Provider</li>
          <li>Le point d'entrée de l'application</li>
          <li>La liste des permissions que l'application a besoin (ex : utiliser le réseau)</li>
          <li>Les prérequis au niveau Hardware pour utiliser l'application</li>
        </ul>
      </article>
      <article>
        <h3>
          build.gradle
            
          <a href="https://developer.android.com/studio/build">DOC</a>
        </h3>
        <pre>
          <code class="gradle"><![CDATA[
                plugins {
                    id 'com.android.application'
                }
                android {
                    namespace 'com.example.appname'
                    compileSdk 32
                    defaultConfig {
                        applicationId "com.example.appname"
                        minSdk 25
                        targetSdk 32
                        versionCode 1
                        versionName "1.0"
                        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
                    }
                    buildTypes {
                        release {
                            minifyEnabled false
                            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                        }
                    }
                    compileOptions {
                        sourceCompatibility JavaVersion.VERSION_1_8
                        targetCompatibility JavaVersion.VERSION_1_8
                    }
                }
                dependencies {
                    implementation 'androidx.appcompat:appcompat:1.5.1'
                    implementation 'com.google.android.material:material:1.7.0'
                    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
                    testImplementation 'junit:junit:4.13.2'
                    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
                    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
                }
            ]]></code>
        </pre>
        <p>Informations Importantes :</p>
        <ul>
          <li>target : La version du SDK utilisé pour compiler</li>
          <li>minSDK : La version minimale supportée</li>
          <li>versionCode et versionName : la version de l'application. Utilisé par le play-store pour savoir s'il y a
                des mises à jour a faire
            </li>
          <li>dependencies : comme maven, permet d'ajouter des librairies externes dans le projet</li>
        </ul>
        <p>Lorsque l'on veut modifier ces valeurs, on peut le faire manuellement, mais il est conseillé de passer par
            l'interface graphique d'Android Studio. Pour y accéder il suffit d'aller dans File
        </p>
        <img class="img-fluid rounded" src="../asset/projet_structure.png" alt=""/>
      </article>
      <article>
        <h2>Version d'Android et choix</h2>
        <p>Cette documentation a été mise à jour en janvier 2023. Lors de la création d'un projet android nous propose
            de l'aide pour choisir la version cible.
        </p>
        <img class="img-fluid rounded" src="../asset/version_api.png" alt="" data-title="Liste des versions d'Android et pourcentage de téléphone  l'utilisant"/>
        <p>Ici on peut voir la liste des versions et des API correspondante. On voit aussi le pourcentage de téléphone
            que l'on va toucher si on choisit une version.
        </p>
        <p>Par exemple La version 7.1 Nougat avec l'API 25 va toucher 90% des téléphones. Dans ce cas, on pourrait se
            dire je vais utiliser l'API 17 qui va toucher 99.9% des téléphones. Pas forcément un bon calcul. Si dans
            votre application vous avez besoin d'utiliser l'empreinte digitale ce ne sera pas possible, car c'est
            seulement dans l'API 23 que cette fonctionnalité apparait.
        </p>
        <p>En gros, plus on utilise des fonctionnalités récentes moins on va toucher de téléphone, car il faut attendre
            que les gens mettent à jour le téléphone. Or sous Android ce n'est pas toujours possible. Le système va
            mettre à jour le téléphone que si celui-ci est capable de le supporter au niveau hardware.
        </p>
        <p>Au moment de concevoir votre application il faudra se poser la question. Quel type de population je veux
            toucher ? Quelles fonctionnalités j'ai absolument besoin d'avoir?
        </p>
      </article>
      <article>
        <h2>
          Logcat et Log
            
          <a href="https://developer.android.com/studio/debug/am-logcat">DOC</a>
        </h2>
      </article>
      <article>
        <h3>Logcat</h3>
        <p>La fenêtre Logcat d'Android Studio affiche les messages système et les messages que vous avez ajoutés à votre
            application avec la classe Log. Il affiche les messages en temps réel et conserve un historique afin que
            vous puissiez voir les messages plus anciens.
        </p>
        <p>Très utile pour déboguer une application :</p>
        <img class="img-fluid rounded" src="../asset/logcat.png" alt=""/>
        <p>On peut aussi filtrer les logs en fonction du label ou de la priorité du log.</p>
      </article>
      <article>
        <h3>
          Log
            
          <a href="https://developer.android.com/reference/android/util/Log">DOC</a>
        </h3>
        <p>
          La classe 
          <kdb>Log</kdb>
           vous permet de créer des messages de journal qui apparaissent dans logcat. En règle
            générale,
            vous devez utiliser les méthodes de journalisation suivantes, répertoriées dans l'ordre de priorité la plus
            élevée à la plus faible.
        
        </p>
        <ul>
          <li>Log.e(String, String) (error)</li>
          <li>Log.w(String, String) (warning)</li>
          <li>Log.i(String, String) (information)</li>
          <li>Log.d(String, String) (debug)</li>
          <li>Log.v(String, String) (verbose)</li>
        </ul>
        <p>Le premier String est le label unique du message. On l'utilisera dans le logcat pour retrouver rapidement
            notre message
        </p>
        <p>Le deuxième String est le message que l'on veut faire apparaître</p>
        <p>Bien faire attention la méthode attend un STRING et pas un autre type. À vous de faire la conversion de type
            s'il y a besoin.
        </p>
        <p>
          Il existe aussi un 😄 
          <a href="https://developer.android.com/reference/android/util/Log#wtf">
            Log.wtf(String,
            String)
        </a>
           😄 pour "What a Terrible Failure" ou Quel terrible échec. À utiliser qu'en cas d'erreur
            incompréhensible.
        
        </p>
        <p>Faire attention que le Logcat ait bien le focus sur le bon téléphone et ensuite le bon projet. Quand on a
            plusieurs téléphones ainsi que des émulateurs en même temps on peut vite se faire avoir.
        </p>
      </article>
    </section>
    <section>
      <h1>Activity</h1>
      <p>La classe Activity est un composant de base d'une application Android. Comprendre la façon dont les activités
        sont
        lancées et assemblées est aussi élément fondamental pour la construction des applications mobiles. Contrairement
        aux
        paradigmes de programmation dans lesquels les applications sont lancées avec une méthode main(), c'est le
        système
        Android initie le code dans une instance Activity en appelant des méthodes de rappel spécifiques qui
        correspondent à des étapes spécifiques de son cycle de vie.
    </p>
      <article>
        <h2>Cycle de vie</h2>
        <p>La classe Activity fournit un certain nombre de methode callback qui permettent à l'activité de savoir qu'un
            état a changé : quand le système crée, arrête ou reprend une activité, ou détruit le processus dans lequel
            l'activité réside.
        </p>
        <p>C'est ce qui permet de contrôler l'activité sans avoir la main sur l'instance de l'objet.</p>
        <div class="container-fluid">
          <div class="row align-items-center">
            <div class="col-sm text-center">
              <img class="img-fluid rounded" src="../asset/activity_lifecycle.png" alt="life cycle of activity"/>
            </div>
            <div class="col-sm">
              <ul>
                <li>onCreate() : Cette méthode est appelée quand le système crée votre activité.</li>
                <li>onStart() : Cette méthode est appelée juste avant que l'activité devienne visible.</li>
                <li>onResume() : Cette méthode est appelée juste avant que l'activité ne commence à interagir
                            avec l'utilisateur.
                        </li>
                <li>onPause() : Cette méthode est appelée lorsque l'activité perd le focus et passe à l'état
                            Pause. L'activité est encore partiellement visible.
                        </li>
                <li>onStop() : Cette méthode est appelée lorsque l'activité n'est plus visible pour
                            l'utilisateur.
                        </li>
                <li>onDestroy() : Cette méthode est appelée avant qu'une activité ne soit détruite.</li>
                <li>onRestart() : Cette méthode est appelée car l'activité a été arrêté et va être redémarré.
                        </li>
              </ul>
            </div>
          </div>
        </div>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/guide/components/activities/activity-lifecycle#oncreate">onCreate()
            </a>
        </h3>
        <p>Logique de démarrage d'application de base qui ne doit se produire qu'une seule fois pendant toute la durée
            de vie de l'activité. Par exemple :
        </p>
        <ul>
          <li>lier des données à une liste</li>
          <li>instancier des variables ou des classes</li>
          <li>récupérer les valeurs qui sont dans l'objet Bundle</li>
          <li>
            Définir les View ou ViewGroup qui composent la vue. Méthode 
            <a href="https://developer.android.com/reference/android/app/Activity#setContentView(android.view.View)">
                setContentView()</a>
            . On verra en détail son utilisation dans la suite du cours.
            
          </li>
        </ul>
        <pre>
          <code class="java"><![CDATA[
                    public class MainActivity extends AppCompatActivity {
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            setContentView(R.layout.activity_main);
                        }
                    }
                ]]></code>
        </pre>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/guide/components/activities/activity-lifecycle#onstart">onStart()</a>
        </h3>
        <p>Juste avant que l'activité soit visible.</p>
        <p>Appelée juste après onCreate ou lorsque l'activité a été stoppé</p>
        <p>méthode qui doit être rapide</p>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/guide/components/activities/activity-lifecycle#onresume">onResume()
            </a>
        </h3>
        <p>Il s'agit de l'état dans lequel l'application interagit avec l'utilisateur et reste dans cet état jusqu'à la
            perte du focus.
        </p>
        <p>Appelé après onStart ou lorsque l'activité a été onPause</p>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/guide/components/activities/activity-lifecycle#onpause">onPause()</a>
        </h3>
        <p>Appelé car l'activité va être quitté.</p>
        <p>C'est ici qu'on doit arrêter toutes les taches qui n'ont pas lieux d'être alors que l'activité n'est plus en
            premier plan (peut être encore visible dans le cas du multiscreen).
        </p>
        <ul>
          <li>stop camera preview</li>
          <li>arrêter d'écouter les sensors</li>
          <li>toute ressource qui affecte l'utilisation de la batterie</li>
          <li>execution de onPause() doit rester bref. Pas de grosse opération ici(sauvegarder data, appeler le
                réseau)
            </li>
        </ul>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/guide/components/activities/activity-lifecycle#onstop">onStop()</a>
        </h3>
        <p>Activité n'est plus visible</p>
        <p>Se produit quand une nouvelle activité est lancée et qu'elle couvre tout l'écran ou quand on va
            simplement quitter l'application.
        </p>
        <p>Effectuer des opérations d'arrêt relativement gourmandes en CPU. Par exemple, pour enregistrer des
            informations dans une base de données.
        </p>
        <p>même si l'activité est stoppée, elle reste en mémoire.</p>
        <p>Si l'activité revient au premier plan on aura onRestart() qui sera appelé.</p>
      </article>
      <article>
        <h3>
          <a href="https://developer.android.com/guide/components/activities/activity-lifecycle#ondestroy">
                onDestroy()
            </a>
        </h3>
        <p>Activité est complétement détruite car :</p>
        <ul>
          <li>l'activité est finie (utilisateur supprime application de la mémoire ou finish() a été appelé)</li>
          <li>Le système détruit l'activité, car il y a un changement de configuration comme rotation écran ou
                multi-screen
            </li>
        </ul>
      </article>
      <article>
        <h3>Test du cycle de vie</h3>
        <p>Toujours le meilleur moyen de comprendre, c'est souvent de tester.</p>
        <pre>
          <code class="java"><![CDATA[
                public class MainActivity extends AppCompatActivity {
                    private static final String TAG = "debug_app";
                    @Override
                    protected void onCreate(Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);
                        setContentView(R.layout.activity_main);
                        Log.d(TAG, "onCreate:");
                    }
                    @Override
                    protected void onStart() {
                        super.onStart();
                        Log.d(TAG, "onStart: ");
                    }
                    @Override
                    protected void onResume() {
                        super.onResume();
                        Log.d(TAG, "onResume: ");
                    }
                    @Override
                    protected void onPause() {
                        super.onPause();
                        Log.d(TAG, "onPause: ");
                    }
                    @Override
                    protected void onStop() {
                        super.onStop();
                        Log.d(TAG, "onStop: ");
                    }
                    @Override
                    protected void onDestroy() {
                        super.onDestroy();
                        Log.d(TAG, "onDestroy: ");
                    }
                }
            ]]></code>
        </pre>
      </article>
      <article>
        <h2>Créer une Activity</h2>
        <p>Pour créer une activité, il y a au moins deux étapes à suivre. Généralement on en ajoute une
            troisième.
        </p>
      </article>
      <article>
        <h3>Créer une classe qui hérite de Activity</h3>
        <pre>
          <code class="java"><![CDATA[
                public class FirstActivity extends Activity {
                }
            ]]></code>
        </pre>
        <p>C'est la classe la plus basique. Dans la pratique, on utilisera AppCompactActivity qui nous permettra d'avoir
            de la compatibilité avec les anciennes versions d'Android
        </p>
        <p>On va aussi redéfinir la méthode onCreate pour définir la vue. Sinon on aura simplement un écran blanc ce qui
            n'est pas très utile.
        </p>
        <pre>
          <code class="java"><![CDATA[
                public class FirstActivity extends AppCompatActivity {
                    @Override
                    protected void onCreate(@Nullable Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);
                        setContentView(R.layout.activity_first);
                    }
                }
            ]]></code>
        </pre>
      </article>
      <article>
        <h3>Ajouter l'activité dans le manifest.xml</h3>
        <pre>
          <code class="xml"><![CDATA[
                <application
                       ... >
                    <activity android:name=".FirstActivity"
                        android:exported="true">
                        <intent-filter>
                            <action android:name="android.intent.action.MAIN" />
                            <category android:name="android.intent.category.LAUNCHER" />
                        </intent-filter>
                    </activity>
                </application>
            ]]></code>
        </pre>
        <p>Le tag intent-filter avec action et category permet d'expliquer que c'est le point d'entrée de
            l'application
        </p>
        <p>Si on avait une deuxième activité le manifest ressemblerait à</p>
        <pre>
          <code class="xml"><![CDATA[
                <application
                       ... >
                    <activity android:name=".FirstActivity"
                        android:exported="true">
                        <intent-filter>
                            <action android:name="android.intent.action.MAIN" />
                            <category android:name="android.intent.category.LAUNCHER" />
                        </intent-filter>
                    </activity>
                    <activity android:name=".SecondActivité"
                        android:exported="false"/>
                </application>
            ]]></code>
        </pre>
        <p>
          <kbd>android:exported</kbd>
          <ul>
            <li>
                    Si la valeur est true, l'activité est accessible à n'importe quelle application et peut être lancée
                    avec le nom exact de la classe.
                </li>
            <li>Si la valeur est false, l'activité ne peut être lancée que par des composants de la même
                    application, des applications ayant le même ID utilisateur ou des composants système privilégiés. En
                    l'absence de filtres d'intent, il s'agit de la valeur par défaut.
                </li>
            <li>doit être a true pour l'activité point d'entrée</li>
          </ul>
        </p>
      </article>
      <article>
        <h3>Créer un fichier XML pour la vue</h3>
        <p>Généralement on crée un fichier xml dans les resources pour définir la vue de l'activité. On peut toute fois
            s'en passer et faire une vue sans le XML, tout en code Java.
        </p>
      </article>
      <article>
        <h3>Utiliser le Wizard de Android Studio</h3>
        <p>Le plus simple est de faire new empty activity qui va faire ces trois étapes pour nous.</p>
        <div class="row">
          <div class="col text-center">
            <img class="img-fluid rounded" src="../asset/create_empty_activity.png" alt=""/>
          </div>
        </div>
      </article>
      <article>
        <h2>Comportement dans l'application</h2>
        <p>Une tâche est un ensemble d'activités avec lesquelles les utilisateurs interagissent lorsqu'ils essaient de
            faire quelque chose dans votre application. Ces activités sont disposées dans une pile - la pile arrière -
            dans l'ordre dans lequel chaque activité est ouverte.
        </p>
        <div class="col text-center">
          <img class="img-fluid rounded" src="../asset/diagram_backstack.png" alt=""/>
        </div>
        <p>
            Lorsque l'activité en cours en démarre une autre, la nouvelle activité est poussée en haut de la pile et
            prend le focus.
        </p>
        <p>L'activité précédente reste dans la pile est arrêtée, mais conserve l'état de son interface.</p>
        <p>Lorsque l'utilisateur effectue l'action de retour ou le programmeur utilise finish(), l'activité en cours est
            supprimé du haut de la pile (l'activité est détruite) et l'activité précédente reprend (l'état précédent de
            son interface utilisateur est restauré).
        </p>
        <p>Les activités de la pile ne sont jamais réorganisées, seulement ajouté ou retirées de la pile</p>
        <p>Fonctionne comme une structure de donnée dernier entré premier sortie on dit aussi (FILO First In Last Out)
        </p>
        <p>Dans votre application il sera important de bien gérer vos activités pour éviter d'en avoir plusieurs même
            instance dans la pile
        </p>
        <div class="row">
          <div class="col text-center">
            <img class="img-fluid rounded" src="../asset/diagram_multiple_instances.png" alt=""/>
          </div>
        </div>
        <p>
          Vous pouvez voir 
          <a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack#ManagingTasks">ici
        </a>
           comment changer le comportement de la pile. Mais une meilleure analyse adaptée au fonctionnement d'Android
            est préférable. En général on ne veut pas changer le comportement par défaut.
        
        </p>
      </article>
      <article>
        <h2>Le Context</h2>
        <p>Interface qui possède les informations globales sur un environnement d'application. Il s'agit d'une classe
            abstraite que chaque Activité implémente. Il permet d'accéder :
        </p>
        <ul>
          <li>à des ressources et à des classes spécifiques à l'application</li>
          <li>des opérations sur l'application telles que le lancement d'activités</li>
          <li>la diffusion et la réception d'intentions</li>
          <li>et bien d'autre</li>
        </ul>
        <p>Énormément de classe ont besoin du Context pour fonctionner.</p>
        <p>Il existe plusieurs façons de mettre la main dessus </p>
        <ul>
          <li>this</li>
          <li>getApplicationContext()</li>
          <li>getBaseContext()</li>
        </ul>
        <p>Voici la plus simple et qui permet de le retrouver facilement partout dans la classe.</p>
        <pre>
          <code class="java"><![CDATA[
                public class MainActivity extends AppCompatActivity {
                    Context context;
                    @Override
                    protected void onCreate(Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);
                        context = this; //don t forget this line, else you will have NullPointer
                        setContentView(R.layout.activity_main);
                    }
                }
            ]]></code>
        </pre>
      </article>
      <article>
        <h2>Container de View</h2>
        <p>Composant visuel de l'application</p>
        <p>Utilise setContentView pour définir la vue</p>
        <p>La vue est composée que d'objet de type View ou ViewGroup. Si on fait le parallèle avec votre cours de React
            JS :
        </p>
        <div class="container-fluid">
          <div class="row align-items-center">
            <div class="col-sm">
              <ul>
                <li>View serait un Composant ou un élément de vue graphique</li>
                <li>ViewGroup serait un Conteneur ou élément de vue pour l'organisation ou le layout</li>
              </ul>
            </div>
            <div class="col-sm text-center">
              <img class="img-fluid rounded" src="../asset/viewgroup_and_view.png" alt=""/>
            </div>
          </div>
        </div>
        <p>Un chapitre entier sera consacré aux interfaces utilisateurs (UI)</p>
      </article>
      <!--    <article>-->
      <!--        <h2>Sauvegarder l'état de l'activité</h2>-->
      <!--    </article>-->
    </section>
    <section>
      <h1>Les interfaces graphiques dans Android</h1>
      <article>
        <h2>Le Layout</h2>
        <p>Le layout (mise en page) définit la structure de votre Interface Utilisateur(UI). Tous les éléments du UI
            sont
            construits à l'aide de 2 type d'objet :
        </p>
        <ul>
          <li>Les View</li>
          <li>Les ViewGroup</li>
        </ul>
        <p>Au final Le Layout est composé d'un arbre d'objet, comme en javascript avec le DOM (Document Object Model)
        </p>
        <img class="img-fluid rounded" src="../asset/ui_hierarchie_layout.png" alt="view hiérarchie" data-title="Arbre des Objets composant un Layout"/>
        <p>Dans la documentation officielle, les View sont appelées communément des "widgets" et les ViewGroup sont
            appelées des "layouts". Pour éviter de confondre entre "Layout" ViewGroup et "Layout" liste des objets
            créant la vue, dans ce cours les View seront des composants et les ViewGroup seront des containeurs de la
            vue et le Layout sera la combinaison de tous les composants et containeurs de la vue.
        </p>
        <p>
          Si on regarde dans la documentation de référence sur les 
          <a href="https://developer.android.com/reference/android/view/ViewGroup">ViewGroup
        </a>
           on peut voir qu'un ViewGroup hérite de View. Au final, on pourrait le voir comme un View possédant une
            
          <![CDATA[
        List<View> ou un containeur de View.
        ]]>
        </p>
        <img class="img-fluid rounded" src="../asset/ui_reference_viewgroup.png"/>
      </article>
      <article>
        <h2>Containeurs et Components existant</h2>
        <p>Dans le SDK Android il y a déjà des View et ViewGroup codés pour nous. Voyons une liste des principaux
            utilisés dans ce cours.
        </p>
      </article>
      <article>
        <h3>Les containeurs</h3>
        <p>Permet d'avoir des enfants à l'intérieur. En fonction des conteneurs les enfants auront un layout différent
        </p>
      </article>
      <article>
        <h4>
          <a href="https://developer.android.com/develop/ui/views/layout/linear">LinearLayout</a>
        </h4>
        <p>L'un des plus simples à utiliser. Il permet d'avoir des enfants les uns en dessous des autres (VERTICAL) ou
            les uns a côté des autres (HORIZONTAL).
        </p>
      </article>
      <article>
        <h4>
          <a href="https://developer.android.com/develop/ui/views/layout/relative">RelativeLayout</a>
        </h4>
        <p>Ce ViewGroupe affiche les enfants dans des positions relatives. La position de
            chaque enfant peut être spécifiée par rapport aux éléments enfants ou par rapport à la zone parent
        </p>
      </article>
      <article>
        <h4>ScrollView</h4>
        <p>Permet d'ajouter un défilement si le contenu dépasse de la vue. Existe aussi le HorizontalScrollView</p>
      </article>
      <article>
        <h4>
          <a href="https://developer.android.com/develop/ui/views/layout/constraint-layout">ConstraintLayout</a>
        </h4>
        <p>ConstraintLayout vous permet de créer des mises en page volumineuses et complexes. Il est similaire au
            RelativeLayout en ce sens que toutes les vues ont disposées en fonction des relations entre les vues, mais
            il est plus flexible que le RelativeLayout. Ce composant ne sera pas traité en cours.
        </p>
      </article>
      <article>
        <h3>Les Composants</h3>
        <p>Ce sont les composants d'affichage, comme un bouton un label ou une image.</p>
        <p>Voici une liste des principaux :</p>
        <ul>
          <li>
            <a href="https://developer.android.com/reference/android/widget/Button">Button</a>
            
                affiche un bouton avec un texte.
            
          </li>
          <li>
            <a href="https://developer.android.com/reference/android/widget/TextView">TextView</a>
            
                permet d'afficher du texte comme un label.
            
          </li>
          <li>
            <a href="https://developer.android.com/reference/android/widget/EditText">EditText</a>
            
                permet de demander à l'utilisateur d'entrer du texte.
            
          </li>
          <li>
            <a href="https://developer.android.com/reference/android/widget/ImageView">ImageView</a>
            
                permet d'afficher une image dans la vue.
            
          </li>
          <li>
            <a href="https://developer.android.com/reference/android/widget/CheckBox">CheckBox</a>
            
                permet d'afficher une checkBox à l'écran
            
          </li>
        </ul>
        <p>Il existe beaucoup d'autre composant, mais on ne peut pas tous les détailler ici.</p>
      </article>
      <article>
        <h2>Les attributs XML</h2>
        <p>Chaque View et ViewGroup ont leurs propres attributs XML. Certains attributs sont spécifiques à un objet
            View, mais ces attributs sont hérités du View parent. Comme tous les composants et containeurs héritent de
            View ils ont plusieurs attributs en commun. Voici les quelques attributs importants. Pour la majorité ils
            viennent de View.
        </p>
      </article>
      <article>
        <h3>id</h3>
        <p>Tout objet View peut avoir un ID entier qui lui est associé, pour identifier de manière unique la vue.
            Lorsque l'application est compilée, cet ID est référencé sous forme d'entier, mais l'ID est
            généralement attribué dans le fichier XML de mise en page sous forme de chaîne, dans l'attribut id. Il
            s'agit d'un attribut XML commun à tous les objets View. Voici la syntaxe de creation d'un id par XML.
        </p>
        <pre>
          <code class="xml"><![CDATA[
                    android:id="@+id/my_id"
                ]]></code>
        </pre>
        <p>ici le "@" veut dire qu'on va accéder aux ressources, le "+id" est là pour demander de créer un id ou
            d'utiliser celui existant.
        </p>
        <p>Comme on l'a vu précédemment on va pouvoir accéder au View depuis son id grâce à findViewById(id_view).</p>
      </article>
      <article>
        <h3>Paramètres du layout</h3>
        <p>
          Tous les attributs jouant sur le layout de la vue vont commencer par layout_quelquechose. Par exemple pour
            définir le la largeur et la hauteur, on devra utiliser 
          <kbd>layout_width</kbd>
           et 
          <kbd>layout_height</kbd>
          .
            On peut définir une taille exacte, mais la plupart du temps, on va préférer utiliser une de ses deux
            valeurs.
        
        </p>
        <ul>
          <li>wrap_content : demande à la vue de prendre la taille de son contenu</li>
          <li>match_parent : demande à la vue de prendre la taille de tout le parent</li>
        </ul>
      </article>
      <article>
        <h3>gravity / layout gravity</h3>
        <p>Gravity est l'attribut à appliquer sur les enfants. Permet d'expliquer la position dans l'espace que l'enfant
            prend. Layout_gravity permet de définir la position par rapport au parent.
        </p>
        <pre>
          <code class="xml"><![CDATA[
                    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                            xmlns:app="http://schemas.android.com/apk/res-auto"
                            xmlns:tools="http://schemas.android.com/tools"
                            android:layout_width="match_parent"
                            android:layout_height="match_parent"
                            android:orientation="vertical"
                            tools:context=".MainActivity">
                        <TextView
                                android:layout_width="match_parent"
                                android:layout_height="wrap_content"
                                android:text="Hello World!" />
                        <TextView
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:layout_gravity="right"
                                android:text="Hello World!" />
                        <TextView
                                android:layout_width="match_parent"
                                android:gravity="right"
                                android:layout_height="wrap_content"
                                android:text="Hello World!" />
                        <TextView
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:layout_gravity="center"
                                android:text="Hello World!" />
                    </LinearLayout>
                ]]></code>
        </pre>
        <div class="container-fluid">
          <div class="row align-items-center">
            <div class="col-sm">
              <img class="img-fluid rounded" src="../asset/manipulation_gravity_result.png"/>
              <p>
                        Voici le résultat dans l'émulateur.
                    </p>
            </div>
            <div class="col-sm">
              <img class="img-fluid rounded" src="../asset/manipulation_gravity_draw.png"/>
              <p>Voici l'explication</p>
            </div>
          </div>
        </div>
      </article>
      <article>
        <h3>Poids des éléments (layout_weight)</h3>
        <p>Voici un attribut spécifique au LinearLayout qui va être très utile pour faire des designs Responsive. Il va
            nous permettre d'expliquer le poids que l'objet va prendre dans la vue
        </p>
        <p>Le LinearLayout va additionner tous les poids et faire en sorte que la vue la fraction désirée du poids
            total.
        </p>
        <pre>
          <code class="xml"><![CDATA[
                    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                            xmlns:app="http://schemas.android.com/apk/res-auto"
                            xmlns:tools="http://schemas.android.com/tools"
                            android:layout_width="match_parent"
                            android:layout_height="match_parent"
                            android:orientation="vertical"
                            tools:context=".MainActivity">
                        <Button
                                android:layout_width="match_parent"
                                android:layout_height="0dp"
                                android:layout_weight="40"
                                android:text="btn 1" />
                        <Button
                                android:layout_width="match_parent"
                                android:layout_height="0dp"
                                android:layout_weight="60"
                                android:text="btn 2" />
                    </LinearLayout>
                ]]></code>
        </pre>
        <p>Ici comme le LinearLayout est vertical il va additionner tous les poids soit 60+40 = 100 et faire en sorte
            que le premier bouton fasse 40/100 et le deuxième 60/100
        </p>
        <img class="img-fluid rounded" src="../asset/manipulation_weight_verticale.png"/>
        <pre>
          <code class="xml"><![CDATA[
                    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                            xmlns:app="http://schemas.android.com/apk/res-auto"
                            xmlns:tools="http://schemas.android.com/tools"
                            android:layout_width="match_parent"
                            android:layout_height="match_parent"
                            android:orientation="horizontal"
                            tools:context=".MainActivity">
                        <Button
                                android:layout_width="0dp"
                                android:layout_height="match_parent"
                                android:layout_weight="2"
                                android:text="btn 1" />
                        <Button
                                android:layout_width="0dp"
                                android:layout_height="match_parent"
                                android:layout_weight="5"
                                android:text="btn 2" />
                    </LinearLayout>
                ]]></code>
        </pre>
        <p>Dans le cas ou le LinearLayout est horizontal le poids sera sur le width</p>
        <img class="img-fluid rounded" src="../asset/manipulation_weight_horizontale.png"/>
      </article>
    </section>
    <section>
      <h1>Manipulation des vues</h1>
      <article>
        <h2>Création de la vue</h2>
        <p>Il existe 3 façons de créer des UI :</p>
        <ul>
          <li>
            En utilisant le XML dans
                
            <kbd>res/layout</kbd>
          </li>
          <li>En créant des instances programmatiquement de ViewGroup et de View (Code Java)</li>
          <li>En Combinant XML et Code Java</li>
        </ul>
        <p>Dans tous les cas, il faudra définir le Layout dans l'Activity. Pour cela on devra utiliser la méthode
            setContentView. Il existe plusieurs redéfinitions de cette méthode pour pouvoir affecter le layout à
            l'Activity en fonction de la façon que l'on veut utiliser.
        </p>
        <pre>
          <code class="java"><![CDATA[
                    public class MainActivity extends AppCompatActivity {
                        Context context;
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            context = this;
                            //set UI width XML File
                            setContentView(R.layout.activity_main); //we give here reference of XML file
                            
                            //set view width Java File
                            LinearLayout container = new LinearLayout(context);
                            setContentView(container);
                        }
                    }
                ]]></code>
        </pre>
        <p>Comme on voit, on définit le Layout dans onCreate. Normalement, on n'appelle pas deux fois setContentView,
            mais si vous le faîte, seul le dernier va définir la vue en écrasant le précédent.
        </p>
      </article>
      <article>
        <h3>En Utilisant le XML</h3>
        <p>
          Pour ce faire il faudra créer un fichier XML dans les ressources. L'utilisation de XML facilite grandement le
            design du layout. Il permet de styliser la vue un peu comme en CSS dans les pages HTML (Le HTML est du XML).
            Dans l'IDE Android Studio on a aussi la possibilité d'utiliser un outil graphique : le 
          <a href="https://developer.android.com/studio/write/layout-editor">Layout Editor
            </a>
          . Il va nous permettre de créer le layout et voir le résultat dans l'Activity sans lancée l'application
            (jusqu'à certaines limites).
        
        </p>
        <p>Pour ouvrir le Layout Editor, il suffit de cliquer sur un fichier XML de layout dans les ressources
            (res/layout). Il existe trois modes de vue :
        </p>
        <img class="img-fluid rounded" src="../asset/ui_layout_editor_view_mode.png"/>
        <ul>
          <li>Le mode Code : on aura accès seulement au XML</li>
          <li>Le mode Split : accès au XML et à la preview du XML. Sera souvent utiliser en cours</li>
          <li>Le mode Design : accès qu'à la preview. Permet d'ajouter des View ou ViewGroup par Drag And Drop ou
                encore d'accéder à tous les attributs possibles pour chaque View.
            </li>
        </ul>
        <p>Voici un exemple de XML "activity_main.xml" qui va créer un LinearLayout comme containeur principal avec un
            TextView comme enfant
        </p>
        <pre>
          <code class="xml"><![CDATA[
                        <?xml version="1.0" encoding="utf-8"?>
                        <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                                xmlns:app="http://schemas.android.com/apk/res-auto"
                                xmlns:tools="http://schemas.android.com/tools"
                                android:layout_width="match_parent"
                                android:layout_height="match_parent"
                                android:orientation="vertical"
                                tools:context=".MainActivity">
                            <TextView
                                    android:layout_width="wrap_content"
                                    android:layout_height="wrap_content"
                                    android:text="Hello World!" />
                        </LinearLayout>
                ]]></code>
        </pre>
        <p>Il faudra aussi avoir dans le code java l'instruction setContentView pour définir la vue.</p>
        <pre>
          <code class="java"><![CDATA[
                    public class MainActivity extends AppCompatActivity {
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            setContentView(R.layout.activity_main);
                        }
                    }
                ]]></code>
        </pre>
        <p>On expliquera plus tard le R.layout.activity_main, mais pour faire rapide, c'est le moyen d'accéder aux
            Ressources depuis le code Java. On verra qu'il existe la même chose quand on est dans le XML.
        </p>
      </article>
      <article>
        <h3>En utilisant le Java</h3>
        <p>Il faudra créer des instances des différents éléments de la vue que vous voulez voir apparaître.
            Inconvénient il faudra parfois aller chercher la méthode qui correspond à l'attribut XML pour modifier le
            composant.
        </p>
        <p>Dans l'exemple xml précédent pour définir la taille du composant, on utilise l'attribut layout_width et
            layout_height. Si on voulait faire la meme chose juste programmatiquement on ferait.
        </p>
        <pre>
          <code class="java"><![CDATA[
                TextView tv = new TextView(this);
                LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
                tv.setLayoutParams(params);
                ]]></code>
        </pre>
        <p>Ici on voit qu'on doit passer par un objet LayoutParams pour donner la largeur et la hauteur du composant.
        </p>
        <p>Si l'on veut exactement la même chose que dans le fichier XML précédent, on devra avoir le code :</p>
        <pre>
          <code class="java"><![CDATA[
                    public class MainActivity extends AppCompatActivity {
                        Context context;
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            context = this;
                            //create instance of linear layout
                            LinearLayout linearLayoutMain = new LinearLayout(context);
                            linearLayoutMain.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
                            linearLayoutMain.setOrientation(LinearLayout.VERTICAL);
                            //add linearLayout as main container of activity
                            setContentView(linearLayoutMain);
                            //create textview
                            TextView textView = new TextView(context);
                            textView.setText("Hello World!");
                            textView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
                            //set text view as child of linearlayout
                            linearLayoutMain.addView(textView);
                        }
                    }
                ]]></code>
        </pre>
      </article>
      <article>
        <h3>En Combinant XML et Code Java</h3>
        <p>Au final, c'est rarement le XML ou le Java que l'on va utiliser pour créer nos Layout. Mais plus
            une combinaison des deux.
        </p>
        <p>Quand on voudra ajouter des événements ou modifier la vue pendant l'exécution, on n'aura pas le choix de le
            faire en Java.
        </p>
        <p>Imaginons un mock up comme celui la</p>
        <img class="img-fluid rounded" src="../asset/ui_xml_and_java.png" alt="java and xml"/>
        <p>Si les vignettes rouges (une image et un texte) proviennent d'une base de donnée, on ne pourra pas savoir
            combien il y en aura en tout. On n'aura pas le choix de mettre la main sur la boite grise et d'ajouter
            programmatiquement les vignettes dans la vue. Par contre, on utilisera le XML pour styliser la vue.
        </p>
      </article>
      <article>
        <h2>Accéder aux View dans l'Activity</h2>
        <p>Souvent on va vouloir "mettre la main" sur une vue créée en XML, pour être capable d'interagir avec elle à
            travers le code Java. Comme dans l'exemple précédent où on voulait remplir la boite grise de Vignette.
        </p>
        <p>Dans la classe View il existe un attribut id. C'est grâce à cet id que l'on va être capable de "mettre la
            main" sur une vue particulière dans une activity.
        </p>
        <p>Il existe une methode findViewById(int id), cette méthode devrait vous rappeler une méthode utiliser en
            JavaScript pour mettre la main sur un élément du DOM (document.getElementById()).
        </p>
        <p>Reprenons l'exemple précédent avec le TexView.</p>
        <pre>
          <code class="xml"><![CDATA[
                    <?xml version="1.0" encoding="utf-8"?>
                    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                            xmlns:app="http://schemas.android.com/apk/res-auto"
                            xmlns:tools="http://schemas.android.com/tools"
                            android:layout_width="match_parent"
                            android:layout_height="match_parent"
                            android:orientation="vertical"
                            tools:context=".MainActivity">
                        <TextView
                                android:id="@+id/text_view"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:text="Hello World!" />
                    </LinearLayout>
                ]]></code>
        </pre>
        <p>
          La ligne android:id="@+id/text_view" permet d'ajouter un attribut id sur le TextView, la valeur de l'id sera
            
          <b>text_view</b>
          . On expliquera plus tard le @ et le +. Voilà le code pour accéder au TexteView depuis le
            Java.
        
        </p>
        <pre>
          <code class="java"><![CDATA[
                    public class MainActivity extends AppCompatActivity {
                        Context context;
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            context = this;
                            setContentView(R.layout.activity_main);
                            //access to textview
                            TextView textView = findViewById(R.id.text_view);
                            //change value of textview
                            textView.setText("New text to print");
                        }
                    }
                ]]></code>
        </pre>
        <p>Attention normalement findViewById est une methode de View, mais ils ont redéfini cette méthode dans
            Activity pour aller chercher directement dans le Layout de la vue.
        </p>
      </article>
      <article>
        <h2>Sérialisation / Desérialisation</h2>
        <p>La sérialisation est utilisée pour convertir un objet en un flux d'octets qui peut être envoyé vers
            n'importe quelle autre programme en cours d'exécution via un réseau ou peut être conservé sur le disque dans
            le but de le reconstruire plus tard.
        </p>
        <p>La desérialisation est le procédé inverse qui permettra de reconstruire un objet depuis le flux d'octets</p>
        <p>Il existe plusieurs formats de sérialisation comme :</p>
        <ul>
          <li>En Java, implémenter l'interface Serializable</li>
          <li>le JSON</li>
          <li>le XML</li>
        </ul>
        <p>Connaitre le format utilisé est très important, pour être capable de faire l'opération dans les deux sens.
        </p>
        <img class="img-fluid rounded" src="../asset/manipulation_serialization.png"/>
      </article>
      <article>
        <h2>La désérialisation en Android</h2>
        <p>
          Pour nous permettre désérialiser il existe un objet 
          <a href="https://developer.android.com/reference/android/view/LayoutInflater">LayoutInflater</a>
          , à qui on
            va donner le fichier XML à transformer en View.
        
        </p>
        <p>Grâce à cet objet, on va pouvoir créer des vues en XML est les désérialiser quand on en aura besoin.</p>
        <p>
          Soit le XML suivant
            
          <kbd>small_view.xml</kbd>
        </p>
        <pre>
          <code class="xml"><![CDATA[
                    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                            android:layout_width="match_parent"
                            android:layout_height="match_parent"
                            android:orientation="horizontal"
                            android:padding="5dp">
                        <TextView
                                android:layout_width="0dp"
                                android:layout_height="wrap_content"
                                android:layout_weight="10"
                                android:background="#f00"
                                android:gravity="center"
                                android:textSize="20dp"
                                android:textColor="#fff"
                                android:text="Left" />
                        <TextView
                                android:layout_width="0dp"
                                android:layout_height="wrap_content"
                                android:layout_weight="10"
                                android:background="#0f0"
                                android:gravity="center"
                                android:textSize="20dp"
                                android:textColor="#fff"
                                android:text="Right" />
                        <TextView
                                android:id="@+id/tv_view_number"
                                android:layout_width="0dp"
                                android:layout_height="wrap_content"
                                android:layout_weight="10"
                                android:background="#00f"
                                android:gravity="center"
                                android:textSize="20dp"
                                android:textColor="#fff"
                                android:text="No " />
                    </LinearLayout>
                ]]></code>
        </pre>
        <p>Si dans une activité, on veut ajouter 10 fois ce layout on devrait faire ceci.</p>
        <pre>
          <code class="java"><![CDATA[
                    public class InflatorActivity extends AppCompatActivity {
                        Context context;
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            context = this;
                            LinearLayout llMain = new LinearLayout(context);
                            llMain.setOrientation(LinearLayout.VERTICAL);
                            setContentView(llMain);
                            for (int i = 0; i < 10; i++) {
                                //deserialization of view
                                LinearLayout linearLayoutSmallView = (LinearLayout) LayoutInflater.from(context).inflate(R.layout.small_view,null);
                                TextView textViewNumberView = linearLayoutSmallView.findViewById(R.id.tv_view_number);
                                textViewNumberView.setText("No : " + (i+1));
                                llMain.addView(linearLayoutSmallView);
                            }
                        }
                    }
                ]]></code>
        </pre>
        <div class="container-fluid">
          <div class="row align-items-center">
            <div class="col-sm">
              <img class="img-fluid rounded" src="../asset/manipulation_inflateur_small_view.png"/>
            </div>
            <div class="col-sm">
              <p>Ici on voit qu'on a ajouté 10 fois la petite vue.</p>
              <p>
                Une fois désérialisé on peut aussi aller chercher un element de la petite vue grace a
                        findViewById, mais ici il faudra faire :
                        
                <kbd>viewToInspect.findViewById</kbd>
              </p>
            </div>
          </div>
        </div>
        <p>Si on reprend l'exemple ou on mélange XML et Java.</p>
        <img class="img-fluid rounded" src="../asset/ui_xml_and_java.png"/>
        <p>On va pouvoir mettre la main sur le containeur gris et ensuite dans une boucle désérialiser plusieurs fois le
            conteneur rouge et aller changer la valeur dedans.
        </p>
      </article>
    </section>
    <section>
      <h1>
        Les
        
        <a href="https://developer.android.com/guide/components/intents-filters#Types">Intent</a>
      </h1>
      <p>Intent est un objet messager pouvant réaliser une action sur les composants principaux. Il permet de faciliter la
        communication. Il existe trois cas d'utilisation :
    </p>
      <ul>
        <li>Démarrer une Activité :</li>
        <li>Démarrer un Service :</li>
        <li>Démarrer un Broadcast :</li>
      </ul>
      <article>
        <h2>Introduction</h2>
        <p>il existe 2 types d'Intent:</p>
        <ul>
          <li>Intent Explicite : On va donner le nom spécifique de l'activité qui va réaliser l'action. Plus utiliser
                pour démarrer des activités qui sont dans notre application
            </li>
          <li>Intent Implicite : Ici on ne connait pas le nom de l'activité, mais on connait l'action que l'on
                voudrait réaliser(ex : voir image, envoyer sms, chercher fichier). C'est le système qui va chercher dans
                les applications les activités capables de réaliser l'action et nous demander de choisir dans une liste.
                Très utile pour démarrer des activités qui se trouvent dans une autre application.
            </li>
        </ul>
        <p>Dans le cadre de ce cours, on va se concentrer sur les intents explicites. On peut lister 3 cas d'utilisation
            lorsque l'on démarre une activité :
        </p>
        <ul>
          <li>Sans passage d'information</li>
          <li>Avec passage d'information</li>
          <li>Avec retour d'information</li>
        </ul>
      </article>
      <article>
        <h2>Intent explicite</h2>
      </article>
      <article>
        <h3>Sans passage d'information</h3>
        <p>Le plus simple, on va juste donner le nom de l'activité que l'on veut démarrer.</p>
        <pre>
          <code class="java"><![CDATA[
                Intent intent = new Intent(ctx,ClassName.class);
                startActivity(intent);
            ]]></code>
        </pre>
        <ul>
          <li>
            <kbd>ctx</kbd>
            
                : représente le Context de l'application.
            
          </li>
          <li>
            <kbd>ClassName.class</kbd>
            
                : représente le type de la classe à démarrer. le 
            <em>.class</em>
             est utilisé pour récupérer le type.
                Très utilisé en programmation quand on utilise les 
            <a href="https://docs.oracle.com/javase/tutorial/extra/generics/index.html">Génériques
            </a>
             ou que l'on fait de la
                
            <a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Réflexion</a>
          </li>
        </ul>
        <p>startActivity() va demander au système de créer une nouvelle Activité et l'ajouter en haut de la pile des
            activités. C'est donc celle-ci qui va devenir visible.
        </p>
      </article>
      <article>
        <h3>Avec passage d'information</h3>
        <div class="container-fluid">
          <div class="row">
            <div class="col-sm-3 text-center">
              <img class="img-fluid rounded" src="../asset/intent_structure.png" alt="" data-title="Structure schématique d'un objet Intent"/>
            </div>
            <div class="col-sm-9">
              <p>L'objet Intent est un messager, il peut donc aussi contenir un message. On va utiliser l'objet
                        extra pour sauvegarder de l'information. Celui-ci se comporte comme un HashMap avec une clef et
                        une valeur.
                    </p>
              <pre>
                <code class="java"><![CDATA[
                            Intent intent = new Intent(this, SecondeActivity.class);
                            intent.putExtra("name","user name");
                            intent.putExtra("id", "456-fesdf-464sdf");
                            intent.putExtra("year", 27);
                            startActivity(intent);
                        ]]></code>
              </pre>
              <p>Une fois dans SecondeActivity il faudra en premier lieu mettre la main sur l'Intent qui a
                        démarré l'activité. Pour cela, on utilise getIntent().
                    </p>
              <p>Reste à récupérer les valeurs avec les mêmes clefs.</p>
              <pre>
                <code class="java"><![CDATA[
                            Intent intent = getIntent();
                            String nameValue = intent.getStringExtra("name");
                            String idValue = intent.getStringExtra("id");
                            int yearValue =  intent.getIntExtra("year", -1);
                        ]]></code>
              </pre>
              <p>dans le cas de getIntExtra on nous demande la valeur par défaut s'il ne trouve pas la clef.</p>
            </div>
          </div>
        </div>
        <p>On peut schématiser par</p>
        <div class="text-center">
          <img class="img-fluid rounded text-center" src="../asset/intent_with_data.png" alt=""/>
        </div>
      </article>
      <article>
        <h3>Avec information retour</h3>
        <p>Dance ce cas, on va devoir démarrer l'activité en expliquant qu'on attend un résultat en retour.</p>
        <pre>
          <code class="java"><![CDATA[
                ActivityResultLauncher<Intent> resultActivity = registerForActivityResult(
                        new ActivityResultContracts.StartActivityForResult(),
                        new ActivityResultCallback<ActivityResult>() {
                            @Override
                            public void onActivityResult(ActivityResult result) {
                                if (result.getResultCode() == RESULT_OK) {
                                    //do instruction when result
                                    Intent intent = result.getData();
                                    String dataString = intent.getStringExtra("dataKey");
                                }
                            }
                        }
                );
                Intent intent = new Intent(this, SecondeActivity.class);
                resultActivity.launch(intent);
            ]]></code>
        </pre>
        <p>ActivityResultLauncher est comme un événement qu'on utiliserait. C'est la méthode onActivityResult qui sera
            appelée quand on reviendra sur l'activité. La méthode result.getData() nous permettra de mettre la main sur
            l'Intent avec les données qui proviennent de l'autre activité, ici SecondeActivity.
        </p>
        <p>Voyons le code dans la deuxième activité pour ajouter de l'information.</p>
        <pre>
          <code class="java"><![CDATA[
                button.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Intent intent = new Intent();
                        intent.putExtra("dataKey","hello data"); //1
                        setResult(RESULT_OK, intent); //2
                        finish(); //3
                    }
                });
            ]]></code>
        </pre>
        <p>Ici on exécute du code quand on clique sur un bouton :</p>
        <ul>
          <li>
                //1 : on ajoute de l'info dans l'Intent
            </li>
          <li>
                //2 : méthode qui permet de définir le code du résultat (RESULT_OK, RESULT_CANCEL) et l'Intent avec les
                données en deuxième paramètre. Ce deuxième paramètre est optionnel. Si par exemple on envoie
                RESULT_CANCEL comme code, on ne voudra peut-être pas ajouter d'Intent.
            </li>
          <li>//3 : permet de tuer programmatiquement l'Activity</li>
        </ul>
      </article>
    </section>
    <section>
      <h1>Les ressources dans Android</h1>
      <p>Une application Android est composée de beaucoup plus que juste du code Java. Il y a aussi des ressources
        séparées du code source comme des images, des fichiers audio et beaucoup d'autre.
    </p>
      <article>
        <h2>Les différents types de ressource</h2>
        <p>
            Les ressources sont les fichiers externes et le contenu statique, tels que les bitmaps, les styles, les
            strings, les couleurs ...
        </p>
        <p>
            Vous devriez toujours externaliser les ressources d'application telles que les images et les chaînes de
            votre
            code, afin de pouvoir les gérer de manière indépendante.
        </p>
        <p>Android nous propose de regrouper les ressources dans des répertoires spécialement nommés.
        </p>
        <p>A chaque fois que vous ajoutez une ressource, Android Studio va générer automatiquement une référence pour
            pouvoir y accéder.
        </p>
        <pre>
          <code class="terminal"><![CDATA[
                    MyProject/
                        src/
                            MyActivity.java
                        res/
                            drawable/
                                graphic.png
                            layout/
                                main.xml
                                info.xml
                            mipmap/
                                icon.png
                            values/
                                strings.xml
                ]]></code>
        </pre>
        <p>
          Voici la liste complete des ressources
            
          <a href="https://developer.android.com/guide/topics/resources/available-resources">Liste Ressources</a>
        </p>
      </article>
      <article>
        <h2>Les qualifiers</h2>
        <p>Lorsque l'on rajoute une ressource, que ce soit un String, une image, un layout, ou autre on peut préciser
            comment la
            ressource doit se comporter selon différents critères et permettre ainsi au système de choisir quelle
            ressource utiliser.
        </p>
        <img class="img-fluid rounded" src="../asset/ressources_qualifier_liste.png" alt=""/>
      </article>
      <article>
        <h3>qualifier - orientation</h3>
        <p>On peut par exemple sur un layout xml ajouter le qualifier orientation.</p>
        <img class="img-fluid rounded" src="../asset/ressources_qualifier_orientation_portrait.png" alt=""/>
        <p>Ici on a ajouté le qualifier orientation portrait. Si le téléphone est en mode portrait, le système va
            automatiquement choisir ce fichier pour l'affichage.
        </p>
        <p>Si 'on veut ajouter le qualifier landscape sur un autre layout, pour que le système soit capable de choisir,
            il va falloir avoir exactement le même nom de fichier, mais avec le qualifier landscape. Si vous faites cela
            vous devriez obtenir cela dans la zone projet.
        </p>
        <img class="img-fluid rounded" src="../asset/ressources_qualifier_orientation_both.png" alt=""/>
        <p>Si on regarde ce qu'Android Studio a fait, il a créé deux repertoires avec le qualifier dessus. Mais
            finalement, on a deux fichiers avec le même nom.
        </p>
        <img class="img-fluid rounded" src="../asset/ressources_qualifier_folder.png" alt=""/>
      </article>
      <article>
        <h3>qualifier - locale</h3>
        <p>Il est aussi possible d'utiliser les qualifiers pour faire l'internationalisation de l'application. Si l'on
            crée une ressource value avec tous les textes de l'application, on pourra dupliquer ce fichier et juste
            traduire le texte. C'est le système qui en fonction de la langue va choisir le fichier à exécuter.
        </p>
        <p>Il faudra au minimum fait le fichier pour la langue par défaut et le fichier pour la langue voulue.</p>
        <img class="img-fluid rounded" src="../asset/ressources_qualifier_local.png" alt=""/>
        <p>Ici on a trois fichiers qui ont le même nom. Pour chaque string, on a mis exactement la même clef. La seule
            chose qui change, c'est la valeur de chacun. Se sera le système qui décidera de choisir le fichier adapté.
        </p>
      </article>
      <article>
        <h2>La Class R</h2>
        <p>Pour permettre de faire le lien entre les ressources et le code Java ou les ressources et le XML, android
            utiliser une classe avec des int dedans pour cela.
        </p>
        <p>À chaque fois que l'on ajoute une ressource, android génère un int permettant d'identifier cette ressource.
            Il ajoute ce int dans la classe R. Voici a quoi ressemble cette classe.
        </p>
        <pre>
          <code class="java"><![CDATA[
                    public class R {
                        public static class layout{
                            public static final int activity_main = 0xabc123;
                            public static final int my_layout = 0xabc124;
                            public static final int other_layout = 0xabc125;
                        }
                        public static class drawable{
                            public static final int image1 = 0xbcd123;
                            public static final int image2 = 0xbcd124;
                            public static final int chat = 0xbcd125;
                        }
                        public static class string{
                            public static final int msg_welcom = 0xefa123;
                            public static final int app_name = 0xefa124;
                            public static final int msg_btn_send = 0xefa125;
                        }
                        public static class color{
                            public static final int color_texte = 0x456fa12;
                            public static final int color_btn = 0x456fa13;
                            public static final int color_border = 0x456fa14;
                            public static final int color_title = 0x456fa15;
                        }
                    }
                ]]></code>
        </pre>
      </article>
      <article>
        <h3>Accéder aux ressources en Java</h3>
        <pre>
          <code class="java"><![CDATA[
                    Resources resources = context.getResources();
                    String stringRessource = resources.getString(R.string.key_ressource);
                    
                    //XXX resValue = resources.getXXX(id);
                ]]></code>
        </pre>
        <p>Depuis le context on peut récupérer toutes les ressources par l'intermédiaire de la classe R.</p>
      </article>
      <article>
        <h3>Accéder aux ressources en XML</h3>
        <p>En xml pour accéder aux ressources, on va utiliser le @</p>
        <pre>
          <code class="xml"><![CDATA[
                    @[package:]type_ressource/nom_ressource
                ]]></code>
        </pre>
        <ul>
          <li>"package" : est optionnel, utilisé pour distinguer les classes R et android.R</li>
          <li>"type" : correspond au type de ressources (layout, drawable, string, id)</li>
          <li>"nom" : correspond au nom de la constante déclarée dans R</li>
        </ul>
        <p>Dans le cas des id on pourra avoir en plus le "+"</p>
        <pre>
          <code class="xml"><![CDATA[
                    @+[package:]type/nom
                ]]></code>
        </pre>
      </article>
      <article>
        <h2>String Dynamique dans les ressources</h2>
        <p>Il est possible d'aller injecter du texte dans un String en utilisant la fonction format</p>
        <pre>
          <code class="xml"><![CDATA[
                    <string name="dyn1">Hello %1$s, you have %2$d years</string>
                ]]></code>
        </pre>
        <p>%n indiquer le rang de l'argument à insérer (%1 correspond au premier argument, %2 au deuxième argument,
            etc.) ;
        </p>
        <p>$x, qui indique quel type d'information on veut ajouter ($s pour une chaîne de caractères et $d)</p>
        <p>Dans le code java on pourra aller remplacer les %n pour la valeur voulue.</p>
        <pre>
          <code class="java"><![CDATA[
                    Resources res = context.getResources();
                    String chaine = res.getString(R.string.dyn1, "durand", 32);
                ]]></code>
        </pre>
      </article>
      <article>
        <h2>Le répertoire Asset</h2>
        <p>Quand dans android on veut ajouter une liste d'image, de fichier ou autre sans se préoccuper du nom, ou que
            l'on désire sauvegarder du contenu pendant l'utilisation de l'application, on va pouvoir utiliser le
            repertoire asset.
        </p>
        <p>Pour ajouter le répertoire asset : clique droit, New &gt; Folder &gt; asset Folder</p>
        <img class="img-fluid rounded" src="../asset/ressources_assets_folder.png" alt=""/>
        <p>Toutes les images du UI vont se retrouver dans le repertoire drawable, mais les images que l'on utilise
            pendant que l'application fonctionne seront préférablement sauvegarder dans asset/.
        </p>
      </article>
      <article>
        <h2>Les méthodes de AssetManager</h2>
        <p>Sur l'objet AssetManager il existe plusieurs méthodes intéressantes</p>
        <ul>
          <li>open(String path) : renvoie un inputStream du fichier que l'on veut ouvrir</li>
          <li>
                list(String path) : renvoie un tableau de String[] pour le path préciser.
            </li>
        </ul>
      </article>
      <article>
        <h3>Accéder à un fichier depuis asset</h3>
        <pre>
          <code class="java"><![CDATA[
                    AssetManager assetManager = getasset(); //into activity
                    AssetManager assetManager = context.getasset(); // everywhere in application
                    try {
                        InputStream inputStream = assetManager.open("fileName");
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                ]]></code>
        </pre>
        <p>Grâce à la méthode open, on va pouvoir récupérer les fichiers désirés depuis asset.</p>
        <p>Si c'est une image, on va pouvoir la retransformer en Bitmap ou en Drawable</p>
        <pre>
          <code class="java"><![CDATA[
                    InputStream inputStream = assetManager.open("fileName");
                    Drawable drawableImage = Drawable.createFromStream(inputStream, null);
                    Bitmap bitmapImage = BitmapFactory.decodeStream(inputStream);
                ]]></code>
        </pre>
      </article>
      <article>
        <h3>Lister les fichiers dans Asset</h3>
        <p>Si on a un répertoire /img dans asset</p>
        <!--         TODO ajouter exemple pour lister fichier dans asset-->
      </article>
    </section>
    <section>
      <h1>Les menus</h1>
      <article>
        <h2>Les différents types de menu</h2>
        <p>
          Référence vers la
            
          <a href="https://developer.android.com/develop/ui/views/components/menus">DOC</a>
        </p>
        <p>Les menus sont un composant d'interface utilisateur courant dans de nombreux types d'applications.</p>
        <p>Depuis Android 3.0 (API 11), les appareils ne sont plus tenus de fournir un bouton physique pour le menu.
            Pour palier è ce problème, on hérite de AppCompatActivity qui va gérer l'absence ou la présence du menu.
        </p>
        <p>Il existe trois types de menu</p>
        <ul>
          <li>Menu d'option (menu hamburger) et barre d'action</li>
          <li>Menu Contextuel</li>
          <li>Popup menu</li>
        </ul>
        <p>Dans le cadre du cours, on détaillera que le premier type de menu. Les autres s'utilisent de façon
            similaire
        </p>
      </article>
      <article>
        <h2>Définition du menu XML</h2>
        <p>
          Comme pour les vues, on peut utiliser le xml pour définir un menu. Le fichier se retrouvera dans le
            répertoire 
          <kbd>res/menu</kbd>
          .
        
        </p>
        <p>Android Studio a ajouté un Menu Éditeur graphique pour la création des menus.</p>
        <p>Pour créer un nouveau menu XML vous devez faire :</p>
        <div class="container-fluid">
          <div class="row align-items-center">
            <div class="col-sm">
              <img class="img-fluid rounded" src="../asset/menu_file_creation.png" alt=""/>
            </div>
            <div class="col-sm">
              <ul>
                <li>clic droit sur le répertoire res</li>
                <li>New</li>
                <li>Android resource file</li>
                <li>selection menu into resource type</li>
              </ul>
            </div>
          </div>
        </div>
        <p>il existe 3 tags pour définir les menus</p>
        <ul>
          <li>menu : conteneur pour les autres menus ou items. Doit être le tag parent dans le fichier XML.</li>
          <li>item</li>
          <li>group</li>
        </ul>
        <div class="text-center">
          <img class="img-fluid rounded" src="../asset/menu_view.png" alt=""/>
        </div>
        <div class="container-fluid">
          <div class="row align-items-center">
            <div class="col-sm-4">
              <ul>
                <li>id : un ID unique qui permettra d'identifier cet item, doit être unique dans le fichier
                            XML
                        </li>
                <li>title : texte qui sera afficher</li>
                <li>icon : référence vers l'image de l'icône</li>
                <li>
                  showAsAction : pour définir si le menu est dans l'action bar ou dans le menu. Valeurs
                            possibles :
                            
                  <ul>
                    <li>always</li>
                    <li>ifRoom</li>
                    <li>never</li>
                  </ul>
                </li>
              </ul>
            </div>
            <div class="col-sm-8">
              <pre>
                <code class="xml"><![CDATA[
                                <menu xmlns:android="http://schemas.android.com/apk/res/android"
                                    xmlns:app="http://schemas.android.com/apk/res-auto">
                                <item
                                        android:id="@+id/menu_play"
                                        android:icon="@android:drawable/ic_media_play"
                                        android:title="play"
                                        app:showAsAction="always" />
                                <item
                                        android:id="@+id/menu_stop"
                                        android:icon="@android:drawable/ic_media_stop"
                                        android:title="stop"
                                        app:showAsAction="always" />
                                <item
                                        android:id="@+id/menu_next"
                                        android:title="next"
                                        app:showAsAction="always" />
                                <item
                                        android:id="@+id/menu_pause"
                                        android:icon="@android:drawable/ic_media_pause"
                                        android:title="pause"
                                        app:showAsAction="ifRoom" />
                                <item
                                        android:id="@+id/menu_reset"
                                        android:title="reset"
                                        app:showAsAction="never" />
                            </menu>
                            ]]></code>
              </pre>
            </div>
          </div>
        </div>
      </article>
      <article>
        <h2>Menu d'option ou action</h2>
        <p>Après définition du menu en XML, il va falloir l'associer à l'activité ou on veut qu'il s'affiche</p>
        <p>Pour cela on va redéfinir la méthode onCreateOptionMenu</p>
        <pre>
          <code class="java"><![CDATA[
                @Override
                public boolean onCreateOptionsMenu(Menu menu) {
                    MenuInflater menuInflater = getMenuInflater();
                    menuInflater.inflate(R.menu.layout_menu, menu);
                    return true;
                }
            ]]></code>
        </pre>
        <p>Comme pour le XML des views on a un dé-sérialiseur, ici le MenuInflater</p>
        <p>Pour ajouter programmatiquement un item on doit utiliser la méthode add() de l'objet Menu</p>
        <pre>
          <code class="java"><![CDATA[
                @Override
                public boolean onCreateOptionsMenu(Menu menu) {
                    int idItem = 1;        // exemple pour ajouter un item
                    int order = 1;
                    MenuItem menuItem = menu.add(0, idItem, order, "mon menu");
                    return true;
                }
            ]]></code>
        </pre>
      </article>
      <article>
        <h2>
          Gérer l'événement
            
          <a href="https://developer.android.com/develop/ui/views/components/menus#RespondingOptionsMenu">clic</a>
        </h2>
        <p>Lorsque l'utilisateur sélectionne un élément dans le menu des options (ou l'action bar), le système appelle
            la méthode onOptionsItemSelected() de votre activité. Cette méthode transmet le MenuItem sélectionné.
        </p>
        <p>On pourra identifier l'item sélectionné grâce à getItemId</p>
        <pre>
          <code class="java"><![CDATA[
                @Override
                public boolean onOptionsItemSelected(@NonNull MenuItem item) {
                    boolean retour = super.onOptionsItemSelected(item);
                    switch (item.getItemId()) {
                        case R.id.menu_play:
                            //action todo
                            retour = true;
                            break;
                        case R.id.menu_stop:
                            //action todo
                            retour = true;
                            break;
                        case R.id.menu_pause:
                            //action todo
                            retour = true;
                            break;
                        case R.id.menu_next:
                            //action todo
                            retour = true;
                            break;
                        case R.id.menu_reset:
                            //action todo
                            retour = true;
                            break;
                    }
                    return retour;
                }
            ]]></code>
        </pre>
      </article>
    </section>
    <section>
      <h1>Les Dialogs</h1>
      <p>
        Référence vers la
        
        <a href="https://developer.android.com/develop/ui/views/components/dialogs">DOC</a>
      </p>
      <p>Une boîte de dialogue est une petite fenêtre qui affiche à l'utilisateur de l'information, ou lui permet de
        prendre une décision ou à saisir des informations supplémentaires.
    </p>
      <p>Les boîtes de dialogue sont dites modales:</p>
      <ul>
        <li>elles bloquent l’interaction avec l'activité en dessous et oblige à faire une action</li>
        <li>elles passent au premier plan et l'activité en dessous est em surbrillance.</li>
      </ul>
      <article>
        <h2>Introduction</h2>
        <p>
          La classe de base pour faire un dialog est 
          <kbd>Dialog</kbd>
           mais on ne va pas utiliser celle-ci
            directement. Il faudrait tout redéfinir ce qui serait beaucoup de travail à chaque fois. On va plutôt
            utiliser une des classes enfant déjà écrite pour nous :
        
        </p>
        <ul>
          <li>AlertDialog : Une boîte de dialogue qui peut afficher un titre, jusqu'à trois boutons, une liste
                d'éléments sélectionnables ou une mise en page personnalisée.
            </li>
          <li>DatePickerDialog ou TimePickerDialog : Une boîte de dialogue avec une interface utilisateur prédéfinie
                qui permet à l'utilisateur de sélectionner une date ou une heure.
            </li>
        </ul>
      </article>
      <article>
        <h2>Modèle Builder</h2>
        <p>Pour créer des AlertDialog il faut utiliser le modèle Builder (Builder pattern).</p>
        <p>Ce modèle permet de construire des objets complexes simplement.</p>
        <div class="container-fluid">
          <div class="row align-items-center">
            <div class="col-sm text-center">
              <img class="img-fluid rounded" src="../asset/builder.png" alt=""/>
            </div>
            <div class="col-sm">
              <p>Utilise les méthodes sur le builder</p>
              <p>méthode create va créer une instance de l'AlertDialog</p>
              <p>permet de créer rapidement un objet en évitant toute la complexité</p>
            </div>
          </div>
        </div>
      </article>
      <article>
        <h2>AlertDialog</h2>
        <p>La classe AlertDialog vous permet de créer une variété de design différent.</p>
        <p>Ce sera souvent la seule dont vous aurez besoin.</p>
        <div class="container-fluid">
          <div class="row align-items-center">
            <div class="col-sm text-center">
              <img class="img-fluid rounded" src="../asset/alert_dialog_layout.png" alt=""/>
            </div>
            <div class="col-sm">
              <p>1 - Titre : permet d'afficher un titre en haut, optionnel</p>
              <p>2 - Zone de contenue : très flexible, elle permet d'afficher un message, des listes ou une vue
                        personnalisée.
                    </p>
              <p>3 - Les boutons d'action : au nombre de trois maximums, optionnel</p>
            </div>
          </div>
        </div>
      </article>
      <article>
        <h3>un message simple</h3>
        <pre>
          <code class="java"><![CDATA[
                AlertDialog.Builder builder = new AlertDialog.Builder(context);
                builder.setTitle("my wonderful title");
                builder.setMessage("my beautiful Message to print ");
                AlertDialog dialog = builder.create();
                dialog.show();
                //or
                AlertDialog dialog = builder.show();
            ]]></code>
        </pre>
        <ul>
          <li>setTitle : permet de définir le titre</li>
          <li>setMessage : définir le contenu sous format texte</li>
          <li>create ou show : il est possible de faire create sur le builder puis show sur l'alertdialog, ou
                directement show sur le builder qui renvoie aussi l'instance de l'alertdialog.
            </li>
        </ul>
        <p>On peut aussi utiliser des strings qui proviendraient des ressources comme R.string.title_ad</p>
      </article>
      <article>
        <h3>Ajouter des boutons</h3>
        <p>Permet de demander une action à l'utilisateur et définir l'action à faire.</p>
        <pre>
          <code class="java"><![CDATA[
                AlertDialog.Builder builder = new AlertDialog.Builder(context);
                builder.setTitle("my wonderful title");
                builder.setMessage("my beautiful Message to print ");
                builder.setPositiveButton("Yes", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        //action if yes is select
                    }
                });
                builder.setNeutralButton("i don't know", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        //action if i don't know is select
                    }
                });
                builder.setNegativeButton("no", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        //action if no select
                    }
                });
                AlertDialog dialog = builder.show();
            ]]></code>
        </pre>
      </article>
      <article>
        <h3>Ajouter une liste d'éléments</h3>
        <p>On peut ajouter 3 types de liste :</p>
        <ul>
          <li>Liste simple traditionnel</li>
          <li>Liste avec un choix possible (radio boutons)</li>
          <li>Liste avec plusieurs choix possible (checkboxes)</li>
        </ul>
      </article>
      <article>
        <h4>Liste simple</h4>
        <pre>
          <code class="java"><![CDATA[
                String[] items = new String[]{"orange","blue","green"};
                AlertDialog.Builder builder = new AlertDialog.Builder(context);
                builder.setTitle("my wonderful title");
                builder.setItems(items, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        String value = items[which];//which = position of item select
                    }
                });
                AlertDialog dialog = builder.show();
            ]]></code>
        </pre>
        <p>Pour ajouter la liste d'éléments, on pourrait aussi utiliser les ressources avec un string-array</p>
        <pre>
          <code class="xml"><![CDATA[
                <string-array name="colors_list">
                    <item>orange</item>
                    <item>blue</item>
                    <item>green</item>
                </string-array>
            ]]></code>
        </pre>
        <p>on aurait alors dans le code</p>
        <pre>
          <code class="java"><![CDATA[
                builder.setItems(R.array.colors_list, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        String[] items = getResources().getStringArray(R.array.colors_list); //pour récupérer les données depuis le répertoire Ressource
                        String value = items[which];//which = position of item select
                    }
                });
            ]]></code>
        </pre>
      </article>
      <article>
        <h4>Liste avec un choix unique</h4>
        <p>On utilisera la méthode setSingleChoiceItems(int itemsId, int checkedItem,final OnClickListener listener)</p>
        <ul>
          <li>itemsId : liste d'élément à afficher. Pourrait être tableau de String aussi</li>
          <li>checkedItem : id de l'élément déjà sélectionné -1 si aucun selectionné</li>
          <li>listener : événement lorsqu'on clique sur l'un des items.</li>
        </ul>
      </article>
      <article>
        <h4>Liste avec un choix multiple</h4>
        <p>On utilisera la méthode setMultiChoiceItems(int itemsId, boolean[] checkedItems, final
            OnMultiChoiceClickListener listener)
        </p>
        <ul>
          <li>itemsId : liste d'élément à afficher. Pourrait être tableau de String aussi</li>
          <li>checkedItems : permet de dire qui est sélectionné, null si aucun</li>
          <li>listener : événement lorsqu'on clique sur l'un des items.</li>
        </ul>
      </article>
      <article>
        <h3>Définir une vue personnalisé</h3>
        <p>Il faut en premier créer une vue, soit programmatiquement, soit en utilisant un fichier xml. Ensuite, il faut
            utiliser la méthode setView(View) sur le Builder pour définir la vue.
        </p>
        <pre>
          <code class="xml" data-title="vue définie en xml"><![CDATA[
                <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                        android:layout_width="match_parent"
                        android:layout_height="match_parent"
                        android:orientation="vertical">
                    <LinearLayout
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:orientation="horizontal">
                        <TextView
                                android:layout_width="0px"
                                android:layout_height="wrap_content"
                                android:layout_weight="30"
                                android:text="login : " />
                        <EditText
                                android:id="@+id/ed_login_ad"
                                android:layout_width="0px"
                                android:layout_height="wrap_content"
                                android:layout_weight="70" />
                    </LinearLayout>
                    <LinearLayout
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:orientation="horizontal">
                        <TextView
                                android:layout_width="0px"
                                android:layout_height="wrap_content"
                                android:layout_weight="30"
                                android:text="password : " />
                        <EditText
                                android:id="@+id/ed_password_ad"
                                android:layout_width="0px"
                                android:layout_height="wrap_content"
                                android:layout_weight="70" />
                    </LinearLayout>
                </LinearLayout>
            ]]></code>
        </pre>
        <pre>
          <code class="java" data-title="code java pour un alert dialog avec une vue perso"><![CDATA[
                AlertDialog.Builder builder = new AlertDialog.Builder(context);
                builder.setTitle("my wonderful title");
                View view = LayoutInflater.from(context).inflate(R.layout.alert_dialog_layout,null);
                builder.setView(view);
                AlertDialog dialog = builder.show();
                ]]></code>
        </pre>
        <p>On peut utiliser la méthode findViewById sur view pour mettre la main sur les éléments de la vue de
            l'alertdialog.
        </p>
        <pre>
          <code class="java"><![CDATA[
                EditText edLogin = view.findViewById(R.id.ed_login_ad);
            ]]></code>
        </pre>
      </article>
      <article>
        <h4>définir un événement</h4>
        <p>On pourrait très bien ajouter un bouton dans la vue et redéfinir l'événement dessus, on pourrait aussi
            ajouter les boutons prédéfinis du builder.
        </p>
        <pre>
          <code class="java"><![CDATA[
                builder.setPositiveButton("Yes", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        AlertDialog alertDialog = (AlertDialog) dialog;
                        EditText edLogin = alertDialog.findViewById(R.id.ed_login_ad);
                    }
                });
            ]]></code>
        </pre>
        <p>
          Lors de la redéfinissions de l'événement, on peut mettre la main sur l'alertdialog en castant (DownCast) le
            DialogInterface. On peut alors aller récupérer n'importe quel élément de la vue avec 
          <kbd>findViewById</kbd>
          .
        
        </p>
      </article>
    </section>
    <section>
      <h1>Les vues personnalisées</h1>
      <article>
        <h2>Les différentes vues personnalisées</h2>
        <p>
          Quand on développe des interfaces graphiques dans android il se peut que les vues pré-construites ne soient
            pas suffisantes. Il va alors falloir faire votre propre vue.
            
          <a href="https://developer.android.com/develop/ui/views/layout/custom-views/custom-components">DOC</a>
        </p>
        <p>Que se soit dans Android en Java ou dans un autre type vue (Swing, WPF) il existe 3 types de vues
            personnalisées.
        </p>
        <ul>
          <li>Vue par combinaison</li>
          <li>Vue par redéfinition</li>
          <li>
            Vue de zéro
                
            <ul>
              <li>Depuis un View</li>
              <li>Depuis un ViewGroup</li>
            </ul>
          </li>
        </ul>
        <p>Pour les deux derniers types de vue il faudra comprendre davantage comment la classe View fonctionne.</p>
      </article>
      <article>
        <h2>Vue par combinaison</h2>
        <p>Dans la vue pas combinaison, le but va être de combiner des vues pré-existantes pour faire notre propre
            vue.
        </p>
      </article>
      <article>
        <h3>InputView</h3>
        <p>Prenons l'exemple d'un champ de formulaire. En général on a toujours un label et une zone de selection de la
            valeur.
        </p>
        <img class="img-fluid rounded" src="../asset/view_input_view.png" alt=""/>
        <p>Ici il faudra créer une classe InputView qui va hériter de LinearLayout.</p>
        <p>L'avantage et que toute la logique se retrouve dans InputView</p>
        <pre>
          <code class="java"><![CDATA[
                    public class InputView extends LinearLayout {
                        TextView textView;
                        EditText editText;
                        public InputView(Context context) {
                            super(context);
                            init();
                        }
                        private void init() {
                            setOrientation(HORIZONTAL);
                            textView = new TextView(getContext());
                            editText = new EditText(getContext());
                            LayoutParams layoutParamsTextView = new LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 30);
                            LayoutParams layoutParamsEditText = new LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 70);
                            textView.setLayoutParams(layoutParamsTextView);
                            textView.setGravity(Gravity.CENTER);
                            textView.setText("default");
                            editText.setLayoutParams(layoutParamsEditText);
                            addView(textView);
                            addView(editText);
                        }
                        public void setLabel(String label) {
                            textView.setText(label);
                        }
                    }
                ]]></code>
        </pre>
        <p>Ici in fait une démo ou on construit tous les objets de la vue programmatiquement, mais on aurait pu faire un
            layout XML et utiliser l'inflateur pour l'affecter à la vue.
        </p>
        <pre>
          <code class="java"><![CDATA[
                    public class MainActivity extends AppCompatActivity {
                        Context context;
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            context = this;
                            LinearLayout llMain = new LinearLayout(context);
                            llMain.setOrientation(LinearLayout.VERTICAL);
                            setContentView(llMain);
                            InputView inputName = new InputView(context);
                            inputName.setLabel("name");
                            InputView inputAge = new InputView(context);
                            inputAge.setLabel("age");
                    
                            llMain.addView(inputName);
                            llMain.addView(inputAge);
                        }
                    }
                ]]></code>
        </pre>
        <p>Il est maintenant facile de rajouter une nouvelle InputView dans notre Layout</p>
        <img class="img-fluid rounded" src="../asset/view_input_view_result.png"/>
      </article>
      <article>
        <h3>InputView en XML</h3>
        <p>Dans Android on a aussi la flexibilité de pouvoir utiliser nos vues personnalisées en Java, mais aussi en
            XML
        </p>
        <p>
          Pour être capable d'utiliser cette vue dans un layout XML il faut 
          <b>absolument</b>
           implémenter le
            constructeur utilisé pendant la dé-sérialisation.
        
        </p>
        <pre>
          <code class="java"><![CDATA[
                    public InputView(Context context) {
                        super(context);
                        //constructor Java
                        init();
                    }
                    public InputView(Context context, @Nullable AttributeSet attrs) {
                        super(context, attrs);
                        //constructor use by xml de-serialization
                        init();
                    }
                ]]></code>
        </pre>
        <pre>
          <code class="xml"><![CDATA[
                    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                            xmlns:app="http://schemas.android.com/apk/res-auto"
                            xmlns:tools="http://schemas.android.com/tools"
                            android:layout_width="match_parent"
                            android:layout_height="match_parent"
                            android:orientation="vertical"
                            tools:context=".MainActivity">
                        <com.cours.devcoursandroid.InputView
                                android:id="@+id/in_name"
                                android:layout_width="match_parent"
                                android:layout_height="wrap_content"/>
                        <com.cours.devcoursandroid.InputView
                                android:id="@+id/in_age"
                                android:layout_width="match_parent"
                                android:layout_height="wrap_content"/>
                    </LinearLayout>
                ]]></code>
        </pre>
        <p>On peut maintenant ajouter autant de vue InputView que l'on veut dans le XML, le problème est qu'on
            désirerait être capable d'ajouter des attributs XML personnalisés. On vas aussi pouvoir le faire, mais on
            doit respecter certaines étapes
        </p>
      </article>
      <article>
        <h4>déclarer un styleable</h4>
        <p>
          Dans les resources il faut ajouter une nouvelle resource de type 
          <![CDATA[ <declare-styleable>]]>
          , on pourra
            alors spécifier les attributs que l'on veut ajouter et le type de chacun.
            
          <a href="https://developer.android.com/develop/ui/views/layout/custom-views/create-view#customattr">DOC</a>
        </p>
        <pre>
          <code class="xml"><![CDATA[
                    <declare-styleable name="InputView">
                        <attr name="label" format="string"/>
                        <attr name="color" format="color" />
                    </declare-styleable>
                ]]></code>
        </pre>
        <p>La valeur de l'attribut name de declare-styleable doit être le même que le nom de la classe héritant de
            View
        </p>
        <p>Dès maintenant on peut ajouter un attribut label sur notre vue. Le seul problème, c'est que l'inflateur ne
            sait pas encore comment appliquer cet attribut. On va devoir préciser ceci dans le deuxième constructeur.
        </p>
      </article>
      <article>
        <h4>Appliquer les attributs dans le constructeur XML</h4>
        <p>Quand on dé-sérialise une vue XML tous les attributs sont passés dans AttributeSet. Android nous permet de
            récupérer dans un TypedArray seulement les attributs personnalisés de notre vue.
        </p>
        <pre>
          <code class="java"><![CDATA[
                    public InputView(Context context, @Nullable AttributeSet attrs) {
                        super(context, attrs);
                        //constructor use by xml de-serialization
                        init();
                        TypedArray customAttribut = getContext().obtainStyledAttributes(attrs, R.styleable.InputView);
                        String labelValueFromXML = customAttribut.getString(R.styleable.InputView_label);
                        int colorText = customAttribut.getColor(R.styleable.InputView_color, Color.BLACK);
                        textView.setTextColor(colorText);
                        setLabel(labelValueFromXML);
                        customAttribut.recycle();
                    }
                ]]></code>
        </pre>
      </article>
      <article>
        <h4>Résultat</h4>
        <p>Voici un exemple du XML avec ce que l'on obtient dans la vue</p>
        <img class="img-fluid rounded" src="../asset/view_xml_attribut_result.png"/>
      </article>
      <article>
        <h2>Fonctionnement des View</h2>
        <!-- TODO add better explanation -->
        <p>Comme les deux prochains types de view nécessite d'aller modifier la vue, il nous faut d'abord comprendre
            comment fonctionne la classe View.
        </p>
        <p>
          Lors du procédé de construction de chaque View, plusieurs méthodes du cycle de vie d'une View sont appelées
            
          <a href="https://developer.android.com/reference/android/view/View#implementing-a-custom-view">DOC</a>
          .
            Voici les principales :
        
        </p>
        <ul>
          <li>onMeasure</li>
          <li>onLayout</li>
          <li>onDraw</li>
        </ul>
        <p>La réalisation du layout et un procédé en 2 passages :</p>
        <ul>
          <li>passage pour donner la taille</li>
          <li>passage pour donner la position</li>
        </ul>
        <p>Finalement une fois que toutes les vues sont dimensionnées et positionnées, ce sera le temps du dessin avec
            onDraw
        </p>
      </article>
      <article>
        <h3>passage pour la taille</h3>
        <p>
          L'étape de la mesure se fera dans 
          <kbd>onMeasure</kbd>
           et se passera aussi en deux passages du haut vers le
            bas dans l'arbre de composant
        
        </p>
        <p>C'est donc le parent qui sera responsable d'appeler measure sur les enfants.</p>
        <p>Il existe deux valeurs de taille dans une View, la taille qu'elle voudrait avoir (measureWidth/measureHeight)
            et la taille qu'elle aura réellement dans la vue (width/height).
        </p>
        <p>C'est pour cela que measure est appelée deux fois.</p>
        <pre>
          <code class="java"><![CDATA[
                    @Override
                    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                        int measureWidth = MeasureSpec.makeMeasureSpec(200, MeasureSpec.AT_MOST);
                        int measureHeight = MeasureSpec.makeMeasureSpec(60, MeasureSpec.AT_MOST);
                        setMeasuredDimension(measureWidth, measureHeight); //must be call to give size
                    }
                ]]></code>
        </pre>
        <p>La méthode setMeasureDimension permet de définir la taille désirée par la vue.</p>
        <p>Pour spécifier le comportement de la vue il measure est en fait une valeur composée de 2 données. La taille
            que l'on veut avoir et une indication pour le parent pour savoir s'il peut changer ou non la taille de
            l'enfant.
        </p>
        <ul>
          <li>UNSPECIFIED</li>
          <li>EXACTLY</li>
          <li>AT_MOST</li>
        </ul>
        <pre>
          <code class="java"><![CDATA[
                    int measure = MeasureSpec.makeMeasureSpec(sizeInPixel, MeasureSpec.AT_MOST);
                ]]></code>
        </pre>
      </article>
      <article>
        <h3>Passage pour le positionnement</h3>
        <p>Une fois dimensionné, c'est le parent qui est responsable d'appeler layout pour positionner tous les
            enfants.
        </p>
      </article>
      <article>
        <h3>Dessiner la vue</h3>
        <p>Ici c'est la méthode onDraw qui est appelée pour expliquer comment dessiner la vue.</p>
        <pre>
          <code class="java"><![CDATA[
                    @Override
                    protected void onDraw(Canvas canvas) {
                        super.onDraw(canvas); // if we want draw parent
                        canvas.drawRect(0,0,getWidth(), 50, new Paint());
                    }
                ]]></code>
        </pre>
        <p>C'est à travers l'objet Canvas que l'on va pouvoir dessiner des rectangles, lignes, points, texte ou images
        </p>
        <p>Lorsque l'on change la vue et que l'on veut que la redessiner, on peut appeler programmatiquement
            invalidate() pour redessiner la vue.
        </p>
      </article>
      <article>
        <h2>Vue par redéfinissions</h2>
        <p>Dans le cas ou la vue existante nous convient presque et que l'on veut juste ajouter des détails de dessin
            dessus, il nous suffit d'en hériter et de redéfinir onDraw.
        </p>
        <p>Voici un exemple où on voudrait ajouter un rectangle sur un bouton.</p>
        <pre>
          <code class="java"><![CDATA[
                    public class CustomButton extends Button implements View.OnClickListener {
                        Paint paint;
                        RectF positionRect;
                        float rectSize;
                        public CustomButton(Context context) {
                            super(context);
                            paint = new Paint(Paint.ANTI_ALIAS_FLAG);
                            paint.setColor(Color.rgb(255, 10, 10));
                            rectSize = 50;
                            setOnClickListener(this);
                            positionRect = new RectF();
                        }
                        @Override
                        protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
                            super.onLayout(changed, left, top, right, bottom);
                            positionRect.set(left + rectSize, getPaddingTop(), left + (2 * rectSize), getHeight() - getPaddingBottom());
                        }
                        @Override
                        protected void onDraw(Canvas canvas) {
                            super.onDraw(canvas);
                            canvas.drawRect(positionRect, paint);
                        }
                        @Override
                        public void onClick(View v) {
                            paint.setColor(Color.rgb(getRandomNb(), getRandomNb(), getRandomNb()));
                            invalidate(); //to redraw view
                        }
                        private int getRandomNb() {
                            return (int) (Math.random() * 255);
                        }
                    }
                ]]></code>
        </pre>
      </article>
      <article>
        <h2>Vue de zéro</h2>
        <p>Lorsque la vue que l'on veut n'existe pas il faudra alors tout faire, pas seulement redéfinir onDraw, mais
            aussi onMeasure. Très puissant, mais plus complexe à implémenter, souvent utilisé pour faire des jeux.
        </p>
        <!-- TODO finish view from scratch -->
      </article>
    </section>
    <section>
      <h1>Les événements Android</h1>
      <p>Il existe plusieurs façons d'intercepter les événements provenant de l'utilisateur. L'approche consiste à
        capturer les événements à partir de l'objet View spécifique avec lequel l'utilisateur interagit. La classe View
        fournit plusieurs moyens de le faire.
    </p>
      <p>On peut catégoriser ces événements en 2 types :</p>
      <ul>
        <li>"Les classiques" comme vu en java ou en C#</li>
        <li>Les spécialisés à Android</li>
      </ul>
      <article>
        <h2>Les événements classiques</h2>
        <p>Comme déjà utilisé dans d'autres cours. C'est une simple méthode de retour (CallBack) que l'on redéfinie.</p>
      </article>
      <article>
        <h3>Event sur les View</h3>
        <p>
          <a href="https://developer.android.com/develop/ui/views/touch-and-input/input-events">DOC</a>
        </p>
        <p>Sur toutes les interfaces qui héritent de View on aura ces événements.</p>
      </article>
      <article>
        <h4>onClick</h4>
        <p>Ceci est appelé lorsque l'utilisateur touche l'élément.</p>
        <pre>
          <code class="java"><![CDATA[
                    view.setOnClickListener(new View.OnClickListener() {
                        @Override
                        public void onClick(View v) {
                            //action to do
                            v.setBackgroundColor(Color.GREEN);
                        }
                    });
                ]]></code>
        </pre>
        <p>On a la View sur laquelle on a cliqué en paramètre de onClick</p>
      </article>
      <article>
        <h4>onLongClick</h4>
        <p>Déclenché quand l'utilisateur reste appuyé sur une view</p>
        <pre>
          <code class="java"><![CDATA[
                    view.setOnLongClickListener(new View.OnLongClickListener() {
                        @Override
                        public boolean onLongClick(View v) {
                            return true;
                        }
                    });
                ]]></code>
        </pre>
        <p>onLongClick renvoie un boolean, il permet de savoir si l'événement a été consommé ou non.</p>
      </article>
      <article>
        <h4>onFocusChange</h4>
        <p>Déclenché lorsque l'utilisateur navigue vers, ou hors de l'élément, en utilisant les touches de navigation
        </p>
        <pre>
          <code class="java"><![CDATA[
                    view.setOnFocusChangeListener(new View.OnFocusChangeListener() {
                        @Override
                        public void onFocusChange(View v, boolean hasFocus) {
                            if(hasFocus){
                                v.setBackgroundColor(Color.GREEN);
                            }else{
                                v.setBackgroundColor(Color.BLUE);
                            }
                        }
                    });
                ]]></code>
        </pre>
        <p>Va fonctionner davantage pour les views qui requièrent une interaction (ex : EditText)</p>
      </article>
      <article>
        <h3>Événement sur changement de Text</h3>
        <pre>
          <code class="java"><![CDATA[
                    editText.addTextChangedListener(new TextWatcher() {
                        @Override
                        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
                        }
                        @Override
                        public void onTextChanged(CharSequence s, int start, int before, int count) {
                        }
                        @Override
                        public void afterTextChanged(Editable s) {
                        }
                    });
                ]]></code>
        </pre>
        <p>Permet de contrôler les actions sur un EditText</p>
      </article>
      <article>
        <h3>Événement sur CheckBox, RadioButton, RadioGroup, ToggleButton</h3>
        <pre>
          <code class="java"><![CDATA[
                    radioButton.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
                        @Override
                        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                        }
                    });
                ]]></code>
        </pre>
      </article>
      <article>
        <h2>Événement Spécialisé</h2>
      </article>
      <article>
        <h2>boolean de retour</h2>
        <ul>
          <li>onLongClick</li>
          <li>onKey</li>
          <li>onTouch</li>
        </ul>
        <p>Cela renvoie un booléen pour indiquer si vous avez consommé l'événement et qu'il ne doit
            pas être porté plus loin. Autrement dit, renvoyez true pour indiquer que vous avez géré l'événement et
            qu'il devrait s'arrêter ici ; renvoie false si vous ne l'avez pas géré et/ou si l'événement doit
            continuer pour tous les autres écouteurs au clic.
        </p>
      </article>
      <article>
        <h3>onTouch</h3>
        <p>C'est un événement particulier des appareils tactiles. Quand l'utilisateur place 1 ou plusieurs doigts sur
            l'écran ça déclenche la méthode de rappel onTouchEvent.
        </p>
        <p>L'événement va prendre en compte :</p>
        <ul>
          <li>la position</li>
          <li>la pression</li>
          <li>la taille</li>
          <li>le nombre de doigt</li>
        </ul>
        <p>C'est à travers l'objet MotionEvent que l'on pourra récupérer toutes ses informations</p>
      </article>
      <article>
        <h4>Détecter l'état</h4>
        <p>Grâce a la Méthode getActionMasked on est capable de récupérer l'état du touch de l'écran. Savoir si le doigt
            est posé, bouge ou est soulevé
        </p>
        <pre>
          <code class="java"><![CDATA[
                    public class MainActivity extends AppCompactActivity {
                    ...
                    // exemple pour une activité, mais même approche pour une sous classe de View
                    @Override
                    public boolean onTouchEvent(MotionEvent event){
                    
                        int action = MotionEventCompat.getActionMasked(event);
                    
                        switch(action) {
                            case (MotionEvent.ACTION_DOWN) :
                                Log.d(DEBUG_TAG,"Action was DOWN");
                                break;
                            case (MotionEvent.ACTION_MOVE) :
                                Log.d(DEBUG_TAG,"Action was MOVE");
                                break;
                            case (MotionEvent.ACTION_UP) :
                                Log.d(DEBUG_TAG,"Action was UP");
                                break;
                            case (MotionEvent.ACTION_OUTSIDE) :
                                Log.d(DEBUG_TAG,"Movement occurred outside bounds " +
                                        "of current screen element");
                                break;
                            default :
                        }
                        return true;
                    }
                    
                    //exemple sur une sous-classe de View
                    View myView = findViewById(R.id.my_view);
                    myView.setOnTouchListener(new OnTouchListener() {
                        public boolean onTouch(View v, MotionEvent event) {
                            //action to do
                            return true;
                        }
                    });
                    
                ]]></code>
        </pre>
      </article>
      <article>
        <h4>Position du ou des doigts</h4>
        <p>Dans le cas où on a 1 doigt, getX et getY nous renvoie la position du doigt sur l'écran.</p>
        <pre>
          <code class="java"><![CDATA[
                    @Override
                    public boolean onTouchEvent(MotionEvent event) {
                        float xPosition = 0;
                        float yPosition = 0;
                        if(event.getActionMasked() == MotionEvent.ACTION_DOWN){
                            xPosition = event.getX();
                            yPosition = event.getY();
                        }
                        if(event.getActionMasked() == MotionEvent.ACTION_MOVE){
                            xPosition = event.getX();
                            yPosition = event.getY();
                        }
                        return super.onTouchEvent(event);
                    }
                ]]></code>
        </pre>
        <p>Dans le cas où il y a plusieurs doigts le système génèrent ces touchEvent</p>
        <p>la méthode getX ou getY peut prendre en paramètre l'index du pointeur dont on veut la position</p>
        <ul>
          <li>ACTION_DOWN : Pour le premier pointeur qui touche l'écran. Toujours à l'index 0 dans le MotionEvent.
            </li>
          <li>ACTION_POINTER_DOWN : Pour les pointeurs supplémentaires qui entrent dans l'écran après le premier.
                L'index du pointeur peut être obtenu en utilisant getActionIndex().
            </li>
          <li>ACTION_MOVE : Une modification s'est produite dans un geste vers un (un ou plusieurs) pointeur(s).</li>
          <li>ACTION_POINTER_UP : Lorsqu'un pointeur autre que le dernier est enlevé. L'index du pointeur qui vient de
                sortir peut être obtenu en utilisant getActionIndex().
            </li>
          <li>ACTION_UP : Envoyé lorsque le dernier pointeur quitte l'écran. Index 0</li>
        </ul>
        <pre>
          <code class="java"><![CDATA[
                    @Override
                    public boolean onTouchEvent(MotionEvent event) {
                        // get pointer index from the event object
                        int pointerIndex = event.getActionIndex();
                        // get pointer ID from pointerIndex
                        int pointerId = event.getPointerId(pointerIndex);
                        // get action
                        int maskedAction = event.getActionMasked();
                        switch (maskedAction) {
                            case MotionEvent.ACTION_DOWN:
                                Log.d(TAG, "index down: " + pointerId);
                                break;
                            case MotionEvent.ACTION_POINTER_DOWN: {
                                Log.d(TAG, "index down: " + pointerId);
                                break;
                            }
                            case MotionEvent.ACTION_MOVE: { // a pointer was moved
                                Log.d(TAG, "index move: " + pointerId);
                                break;
                            }
                            case MotionEvent.ACTION_UP:
                                Log.d(TAG, "index up: " + pointerId);
                                break;
                            case MotionEvent.ACTION_POINTER_UP:
                                Log.d(TAG, "index up: " + pointerId);
                                break;
                        }
                
                        return true;
                    }
                ]]></code>
        </pre>
      </article>
      <article>
        <h2>Gesture Detector</h2>
        <p>Pour aider sur les manipulations de l'onTouch, il y a dans le SDK une interface pour détecter certain type de
            mouvement. C'est le GestureDetector
        </p>
      </article>
      <article>
        <h3>Implementer l'interface</h3>
        <pre>
          <code class="java"><![CDATA[
                            public class EventActivity extends AppCompatActivity implements GestureDetector.OnGestureListener {
                                Context context;
                                @Override
                                protected void onCreate(Bundle savedInstanceState) {
                                    super.onCreate(savedInstanceState);
                                    context = this;
                                    setContentView(R.layout.activity_event);
                                }
                                @Override
                                public boolean onDown(MotionEvent e) {
                                    return false;
                                }
                                @Override
                                public void onShowPress(MotionEvent e) {
                                }
                                @Override
                                public boolean onSingleTapUp(MotionEvent e) {
                                    return false;
                                }
                                @Override
                                public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
                                    return false;
                                }
                                @Override
                                public void onLongPress(MotionEvent e) {
                                }
                                @Override
                                public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                                    return false;
                                }
                            }
                        ]]></code>
        </pre>
      </article>
      <article>
        <h3>Ajouter Gesture Detector</h3>
        <pre>
          <code class="java"><![CDATA[
                    public class EventActivity extends AppCompatActivity implements GestureDetector.OnGestureListener {
                        private String TAG = "debug-app";
                        GestureDetector gestureDetector;
                        Context context;
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            context = this;
                            setContentView(R.layout.activity_event);
                            gestureDetector = new GestureDetector(this,this);
                        }
                        @Override
                        public boolean onDown(MotionEvent e) {
                            return false;
                        }
                        @Override
                        public void onShowPress(MotionEvent e) {
                        }
                        @Override
                        public boolean onSingleTapUp(MotionEvent e) {
                            return false;
                        }
                        @Override
                        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
                            return false;
                        }
                        @Override
                        public void onLongPress(MotionEvent e) {
                        }
                        @Override
                        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                            return false;
                        }
                    }
                ]]></code>
        </pre>
      </article>
      <article>
        <h3>Lier GestureDetector au onTouchEvent</h3>
        <pre>
          <code class="java"><![CDATA[
                    public class EventActivity extends AppCompatActivity implements GestureDetector.OnGestureListener {
                        private String TAG = "debug-app";
                        GestureDetector gestureDetector;
                        Context context;
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            context = this;
                            setContentView(R.layout.activity_event);
                            gestureDetector = new GestureDetector(this,this);
                        }
                        @Override
                        public boolean onTouchEvent(MotionEvent event) {
                            gestureDetector.onTouchEvent(event);
                            return true;
                        }
                        @Override
                        public boolean onDown(MotionEvent e) {
                            return false;
                        }
                        @Override
                        public void onShowPress(MotionEvent e) {
                        }
                        @Override
                        public boolean onSingleTapUp(MotionEvent e) {
                            return false;
                        }
                        @Override
                        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
                            return false;
                        }
                        @Override
                        public void onLongPress(MotionEvent e) {
                        }
                        @Override
                        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                            return false;
                        }
                    }
                ]]></code>
        </pre>
      </article>
    </section>
    <section>
      <h1>Sauvegarde des informations</h1>
      <ul>
        <li>SharedPreferences</li>
        <li>file stream</li>
        <li>Base de donnée SQLITE</li>
      </ul>
      <article>
        <h2>SharedPreferences</h2>
        <a href="https://developer.android.com/training/data-storage/shared-preferences">DOC</a>
        <p>Permet d'enregistrer des informations de petites taille dans une collection sous format clef/valeur:</p>
        <p>Ces informations sont accessibles par n'importe quelle activité de l'application</p>
        <p>Les données persistent malgré un redémarrage ou une mise à jour de l'application</p>
      </article>
      <article>
        <h3>Accéder aux SharedPreferences</h3>
        <pre>
          <code class="java"><![CDATA[
                //si pas besoin de catégoriser les informations
                SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
                //si besoin de catégoriser
                SharedPreferences sharedPreferencesUser = context.getSharedPreferences("user", Context.MODE_PRIVATE);
            ]]></code>
        </pre>
        <p>remarque: on utilise MODE_PRIVATE, mais il n'existe plus d'autre mode que celui-ci. Avant on avait
            MODE_WORLD_WRITEABLE ou MODE_WORLD_READABLE, mais c'est déprécié et si on essaie d'accéder au
            SharedPreferences depuis une autre application, cela déclenche une exception de sécurité
        </p>
      </article>
      <article>
        <h3>Accéder aux données</h3>
        <p>Depuis l'objet SharedPreferences utiliser les méthodes sharedPreferences.getXXX("key", defautValue) ou XX
            correspond à un type primitif et "key" la clef utilisée pour sauvegarder la donnée.
        </p>
        <pre>
          <code class="java"><![CDATA[
                SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
                String guid = sharedPreferences.getString("id",null);
                int age = sharedPreferences.getInt("age",-1);
            ]]></code>
        </pre>
      </article>
      <article>
        <h3>Ajouter des données</h3>
        <p>Pour ajouter des données de type primitif il faut passer par l'objet SharedPreferences.Editor</p>
        <p>
          Une fois ajouté il faut utiliser 
          <kbd>commit</kbd>
           ou 
          <kbd>apply</kbd>
           pour synchroniser les infos sur le
            disque.
        
        </p>
        <pre>
          <code class="java"><![CDATA[
                SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
                SharedPreferences.Editor editor = sharedPreferences.edit();
                editor.putString("userName", "John Doe");
                editor.putFloat("xPosition", 42.56f);
                editor.putFloat("yPosition", 1056.89f);
                editor.apply();
            ]]></code>
        </pre>
        <p>apply() modifie immédiatement l'objet SharedPreferences en mémoire, mais écrit les mises à jour sur le disque
            de manière asynchrone. Vous pouvez également utiliser commit() pour écrire les données sur le disque de
            façon synchrone. Cependant, comme commit() est synchrone, évitez de l'appeler à partir de votre thread
            principal, car cela pourrait suspendre le rendu de l'interface utilisateur.
        </p>
      </article>
      <article>
        <h3>Supprimer des données</h3>
        <p>On peut soit supprimer toutes les données, soit seulement une donnée par clef.</p>
        <p>Doit aussi appeler apply ou commit pour synchroniser les modifications</p>
        <pre>
          <code class="java"><![CDATA[
                SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
                SharedPreferences.Editor editor = sharedPreferences.edit();
               
                //suppression par clef
                editor.remove("userName");
                editor.remove("id");
                editor.apply();
               
                //suppression total
                editor.clear();
                editor.apply();
            ]]></code>
        </pre>
      </article>
      <article>
        <h2>Persistance dans un fichier</h2>
        <p>Même procédé que vue dans le cours de Java I pour manipuler les streams, seul nuance il existe une memoir
            interne ou une memoire externe
        </p>
      </article>
      <article>
        <h3>Écrire/Lire en interne</h3>
        <a href="https://developer.android.com/training/data-storage/app-specific#internal">DOC</a>
        <p>Le mode d'accès est forcément privée</p>
        <p>context.getFilesDir(): Renvoie le chemin absolu du répertoire sur le système de fichiers où les fichiers
            créés avec openFileOutput(String, int) sont stockés.
        </p>
        <p>Aucune autorisation supplémentaire n'est requise pour que l'application appelante puisse lire ou écrire des
            fichiers sous le chemin renvoyé.
        </p>
        <pre>
          <code class="java"><![CDATA[
            File file = new File(context.getFilesDir(), filename);
            ]]></code>
        </pre>
        <p>Ecrire dans un fichier</p>
        <pre>
          <code class="java"><![CDATA[
                String filename = "myFile.txt";
                String fileContents = "Hello world!";
                try (FileOutputStream fos = context.openFileOutput(filename, Context.MODE_PRIVATE)) {
                    fos.write(fileContents.toByteArray());
                }
            ]]></code>
        </pre>
        <p>Lire dans un fichier</p>
        <pre>
          <code class="java"><![CDATA[
                FileInputStream fileInputStream = context.openFileInput(fileName);
                InputStreamReader inputStreamReader =
                        new InputStreamReader(fileInputStream, StandardCharsets.UTF_8);
                StringBuilder stringBuilder = new StringBuilder();
                try (BufferedReader reader = new BufferedReader(inputStreamReader)) {
                    String line = reader.readLine();
                    while (line != null) {
                        stringBuilder.append(line).append('\n');
                        line = reader.readLine();
                    }
                } catch (IOException e) {
                    // Error occurred when opening raw file for reading.
                } finally {
                    String contents = stringBuilder.toString();
                }
            ]]></code>
        </pre>
      </article>
      <article>
        <h3>Lire/écrire dans la mémoire externe</h3>
        <p>Premièrement on doit déclarer une permission dans le manifest</p>
        <pre>
          <code class="xml"><![CDATA[
                <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" />
            ]]></code>
        </pre>
        <p>Pour tester Débrancher le cable, car sinon la mémoire externe sera "monter" sur le pc</p>
        <p>Aucune certitude que les données soient présentes, car elles sont publiques et modifiables par toutes les
            autres applications.
        </p>
        <p>Les repertoires pour stocker des informations suivent un standard pour toutes ses photos, ses musiques et
            fichiers audio.
        </p>
        <pre>
          <code class="java"><![CDATA[
                    File file = new File(Environment.getExternalStorageDirectory().getPath()+ File.separator+ "Android/data"+File.separator + getPackageName() + "/files/"+"myFile.txt" );
                ]]></code>
        </pre>
        <p>Sinon même chose que memoire interne pour manipulation des fichiers.</p>
      </article>
      <article>
        <h2>Base de donnée - BD</h2>
        <p>BD locale, accessible que par l'application (privée) et même que par le téléphone</p>
        <p>
          Le système de gestion de base de donnée est 
          <a href="https://www.sqlite.org/index.html">SQLite</a>
          .
        
        </p>
        <p>
          Android conseil d'utiliser leur framework 
          <a href="https://developer.android.com/training/data-storage/room">
            Room
        </a>
           pour accéder aux bases de données. Dans ce cours, on va utiliser l'API SQLite que Room utilise.
        
        </p>
      </article>
      <article>
        <h3>Création d'une table SQLite</h3>
        <p>
          Dans SQLite il existe que 5
            
          <a href="https://www.sqlite.org/datatype3.html">types</a>
        </p>
        <ul>
          <li>NULL</li>
          <li>INTEGER</li>
          <li>REAL</li>
          <li>TEXT</li>
          <li>BLOB (Binary Barge OBject)</li>
        </ul>
        <p>On peut aussi ajouter des contraintes</p>
        <li>PRIMARY KEY</li>
        <li>NOT NULL</li>
        <li>CHECK</li>
        <li>DEFAULT</li>
        <li>CONSTRAINT KEY</li>
        <p>ex: création d'une table d'étudiant</p>
        <pre>
          <code class="sql"><![CDATA[
                CREATE TABLE etudiant (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    first_name TEXT,
                    last_name TEXT,
                    age
                );
            ]]></code>
        </pre>
      </article>
      <article>
        <h3>Classe pour gérer la BD</h3>
        <p>Pour mettre la main sur la BD on doit passer par une classe qui hérite de SqliteOpenHelper</p>
        <pre>
          <code class="java"><![CDATA[
                public class DataBaseHelper extends SQLiteOpenHelper {
                    public DataBaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) {
                        super(context, name, factory, version);
                    }
                    @Override
                    public void onCreate(SQLiteDatabase db) {
                    }
                    @Override
                    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                    }
                }
            ]]></code>
        </pre>
        <p>Lorsqu on crée une instance de cette classe, on peut ensuite mettre la main sur la BD avec
            getWritableDatabase ou get ReadableDatabase().
        </p>
        <p>Détaillons le constructeur :</p>
        <ul>
          <li>context : le context de l'activité</li>
          <li>name : le nom du fichier de base de donnée</li>
          <li>factory : ici on mettra null. C'est dans le cas où on voudrait passer par les Contents Provider</li>
          <li>version : la version de la bd. Très important, car ce paramètre va avoir une influence sur l'appel des
                méthodes onCreate ou onUpgrade
            </li>
        </ul>
        <p>onCreate : appelé la premiere fois que l'on essaie d'accéder à la BD ou quand la version = 1</p>
        <p>onUpgrade : si on change le numéro de la version cette méthode est alors appelée. On est libre de changer la
            structure des tables ou tous autres actions SQL
        </p>
        <pre>
          <code class="java"><![CDATA[
                @Override
                public void onCreate(SQLiteDatabase db) {
                    db.execSQL("CREATE TABLE etudiant (\n" +
                            "id INTEGER PRIMARY KEY AUTOINCREMENT," +
                            "first_name TEXT," +
                            "last_name TEXT," +
                            "age" +
                            ");");
                    db.execSQL("INSERT INTO etudiant ('first_name','last_name','age') values ('john','doe', 27), ('foo','bar',99);");
                }
                @Override
                public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                    db.execSQL("DROP TABLE IF EXISTS etudiant");
                    onCreate(db);
                }
            ]]></code>
        </pre>
      </article>
      <article>
        <h3>Manager BdHelper</h3>
        <p>Pour gérer les versions et mettre plus facilement la main sur la base de donnée on pourrait créer une classe
            ConnectionDB
        </p>
        <pre>
          <code class="java"><![CDATA[
                public class ConnectionDB {
                    private static int version = 1;
                    private static String bnName = "myBd.db";
                    private static SQLiteDatabase bd = null;
                    private static DataBaseHelper helper;
                    
                    public static SQLiteDatabase getBd(Context context){
                        if(helper == null){
                            helper = new DataBaseHelper(context, bnName, null, version);
                        }
                        bd = helper.getWritableDatabase();
                        return bd;
                    }
                    public static void close(){
                        if(bd!= null &&  !bd.isOpen()){
                            bd.close();
                        }
                    }
                }
            ]]></code>
        </pre>
      </article>
      <article>
        <h3>Gérer les données de la bd</h3>
        <p>On va utiliser la base de donnée comme en JavaII avec un Manager pour chaque table.</p>
        <p>Ici on va faire un EtudiantManager</p>
      </article>
      <article>
        <h4>Ajouter</h4>
        <pre>
          <code class="java"><![CDATA[
                    public class EtudiantManager {
                    
                        public static long add(Context context, Etudiant etudiantToAdd){
                            ContentValues contentValues = new ContentValues();
                            contentValues.put("first_name", etudiantToAdd.getFirstName());
                            contentValues.put("last_name", etudiantToAdd.getLastName());
                            contentValues.put("age", etudiantToAdd.getAge());
                            SQLiteDatabase bd = ConnectionDB.getBd(context); //on réutilise ConnctionDB ici
                            return bd.insert("etudiant", null, contentValues);
                        }
                    }
                ]]></code>
        </pre>
        <p>On utilise un objet ContentValues clef/valeur pour ajouter les données. Les clefs doivent être les mêmes que
            les colonnes de la table.
        </p>
        <p>la methode insert retourne l'id autogénéré.</p>
      </article>
      <article>
        <h4>Supprimer</h4>
        <pre>
          <code class="java"><![CDATA[
                public static void delete(Context context, int idEtudiant){
                    SQLiteDatabase bd = ConnectionDB.getBd(context);
                    bd.delete("etudiant","id = ?" , new String[]{String.valueOf(idEtudiant)});
                }
            ]]></code>
        </pre>
        <p>détaillons les paramètres de la méthode delete</p>
        <pre>
          <code class="java"><![CDATA[
                public int delete (String table,
                                    String whereClause,
                                    String[] whereArgs)
            ]]></code>
        </pre>
        <ul>
          <li>table : le nom de la table</li>
          <li>whereClause : condition de suppression</li>
          <li>whereArgs : valeur pour condition de suppression</li>
        </ul>
        <p>Si on avait écrit la requête SQL pour supprimer un étudiant, on aurait écrit :</p>
        <pre>
          <code class="sql"><![CDATA[
                DELETE FROM etudiant WHERE id = ?
            ]]></code>
        </pre>
        <p>WHERE id = ? : est la condition de suppression ou le whereClause on appelle le ? un joker. Il sera remplacer
            par la valeur voulue.
        </p>
        <p>Si on avait voulu supprimer l'étudiant avec l'id = 7 on aurait eu :</p>
        <pre>
          <code class="sql"><![CDATA[
                DELETE FROM etudiant WHERE id = 7
            ]]></code>
        </pre>
        <p>7 est le whereArgs ou l'argument du where, soit la condition changeante.</p>
        <p>On aurait pu avoir</p>
        <pre>
          <code class="sql"><![CDATA[
                    DELETE FROM etudiant WHERE id = ? AND name LIKE ?
                ]]></code>
        </pre>
        <p>Ici on a 2 conditions dans le where clause. C'est pour cela que le whereArgs est un tableau de String. La
            premiere valeur va correspondre au premier ? et la deuxième valeur au deuxième ?
        </p>
      </article>
      <article>
        <h4>Modifier</h4>
        <pre>
          <code class="java"><![CDATA[
                    public static void update(Context context, Etudiant etudiantToUpdate) {
                        ContentValues contentValues = new ContentValues();
                        contentValues.put("first_name", etudiantToUpdate.getFirstName());
                        contentValues.put("age", etudiantToUpdate.getAge());
                        SQLiteDatabase bd = ConnectionDB.getBd(context);
                        long nbRowChange = bd.update("etudiant", contentValues, "id = ?", new String[]{String.valueOf(etudiantToUpdate.getId())});
                    }
                ]]></code>
        </pre>
        <p>On va réutiliser le même principe que le whereClaus et le whereArgs.</p>
        <p>Seul les valeurs ajoutées dans le ContentValues seront modifiées.</p>
        <p>comme précédemment on doit avoir les mêmes clefs que les noms des colones</p>
      </article>
      <article>
        <h4>Sélectionner des données</h4>
        <pre>
          <code class="java"><![CDATA[
                    public static ArrayList<Etudiant> getAll(Context context) {
                        SQLiteDatabase bd = ConnectionDB.getBd(context);
                        String query = "SELECT * FROM etudiant";
                        ArrayList<Etudiant> etudiants = null;
                        Cursor cursor = bd.rawQuery(query, null);
                        if (cursor.isBeforeFirst()) {
                            etudiants = new ArrayList<>();
                            while (cursor.moveToNext()) {
                                Etudiant etudiant = new Etudiant();
                                etudiant.setId(cursor.getInt(cursor.getColumnIndexOrThrow("id")));
                                etudiant.setFirstName(cursor.getString(cursor.getColumnIndexOrThrow("first_name")));
                                etudiant.setLastName(cursor.getString(cursor.getColumnIndexOrThrow("last_name")));
                                etudiant.setAge(cursor.getInt(cursor.getColumnIndexOrThrow("age")));
                                etudiants.add(etudiant);
                            }
                        }
                        return etudiants;
                    }
                ]]></code>
        </pre>
        <p>L'objet Cursor est quasiment le même que l'objet ResultSet du cours de JavaII. C'est une structure de donnée
            de type Set. On va la parcourir avec la boucle while.
        </p>
        <p>Après l'appelle de moveToNext() on a un nouvel enregistrement de la table. S'il n'y a plus d'enregistrement,
            moveToNext() renverra false
        </p>
        <p>Dans le cas d'une requête avec des paramètres, on va devoir utiliser le whereArgs.</p>
        <p>Exemple pour récupérer les étudiants ayant un âge supérieur à :</p>
        <pre>
          <code class="java"><![CDATA[
                public static ArrayList<Etudiant> getByAgeLimite(Context context, int ageLimite) {
                    SQLiteDatabase bd = ConnectionDB.getBd(context);
                    String query = "SELECT * FROM etudiant where age > ?";
                    ArrayList<Etudiant> etudiants = null;
                    Cursor cursor = bd.rawQuery(query, new String[]{String.valueOf(ageLimite)});
                    if (cursor.isBeforeFirst()) {
                        etudiants = new ArrayList<>();
                        while (cursor.moveToNext()) {
                            Etudiant etudiant = new Etudiant();
                            etudiant.setId(cursor.getInt(cursor.getColumnIndexOrThrow("id")));
                            etudiant.setFirstName(cursor.getString(cursor.getColumnIndexOrThrow("first_name")));
                            etudiant.setLastName(cursor.getString(cursor.getColumnIndexOrThrow("last_name")));
                            etudiant.setAge(cursor.getInt(cursor.getColumnIndexOrThrow("age")));
                            etudiants.add(etudiant);
                        }
                    }
                    return etudiants;
                }
                ]]></code>
        </pre>
      </article>
    </section>
    <section>
      <h1>Le ListView</h1>
      <!--TODO listView-->
    </section>
    <section>
      <h1>Les Sensors</h1>
      <p>La plupart des appareils fonctionnant sous Android ont des capteurs intégrés qui mesurent le mouvement,
        l'orientation et diverses conditions environnementales. Une application météorologique peut utiliser le capteur
        de température et le capteur d'humidité d'un appareil pour calculer et signaler le point de rosée. Un jeu
        pourrait utiliser l'accéléromètre pour déplacer une image avec le mouvement du téléphone.
    </p>
      <p>
        <a href="https://developer.android.com/guide/topics/sensors">DOC</a>
      </p>
      <article>
        <h2>Les Types Sensor</h2>
        <p>il existe 3 catégories de Sensor dans les appareils :</p>
        <ul>
          <li>Sensors de mouvement</li>
          <li>Sensors d'environnement</li>
          <li>Sensors de position</li>
        </ul>
      </article>
      <article>
        <h3>Mouvement</h3>
        <p>
          <a href="https://developer.android.com/guide/topics/sensors/sensors_motion">DOC</a>
          
            Les capteurs de gravité, d'accélération linéaire, de vecteur de rotation, de mouvement significatif, de
            compteur de pas et de détecteur de pas sont soit matériels, soit logiciels.
            Les capteurs de l'accéléromètre et du gyroscope sont toujours basés sur le matériel (hardware).
        
        </p>
      </article>
      <article>
        <h3>Position</h3>
        <p>
          <a href="https://developer.android.com/guide/topics/sensors/sensors_position">DOC</a>
          
            La plate-forme Android propose deux capteurs permettant de déterminer la position d'un appareil : le capteur
            de champ géomagnétique et l'accéléromètre.
        
        </p>
      </article>
      <article>
        <h3>Environnement</h3>
        <p>
          <a href="https://developer.android.com/guide/topics/sensors/sensors_environment">DOC</a>
          
            La plate-forme Android fournit quatre capteurs qui vous permettent de surveiller diverses propriétés
            environnementales. Vous pouvez utiliser ces capteurs pour surveiller l'humidité ambiante relative,
            l'éclairement, la pression ambiante et la température ambiante à proximité d'un appareil Android.
        
        </p>
        <p>Les quatre capteurs d'environnement sont basés sur le matériel et ne sont disponibles que si le fabricant de
            l'appareil les a intégrés à un appareil.
        </p>
      </article>
      <article>
        <h2>Sensor Framework</h2>
        <p>Pour récupérer les données des sensors, ce sera toujours de la même façon à travers le Framework Sensor.</p>
        <p>On utilisera 4 classes/interfaces</p>
        <ul>
          <li>SensorManager : permet d'aider à gérer les Sensors, mettre la main dessus, enregistrer un listener,
                avoir la liste de tous les sensors.
            </li>
          <li>Sensor : récupéré depuis SensorManager, permet d'avoir des informations sur un sensor en particulier.
            </li>
          <li>SensorEvent : événement que l'on va récupérer dans le callBack pour la ou les valeurs du sensor.</li>
          <li>SensorEventListener : événement que l'on enregistrera dans le sensorManager pour écouter le sensor</li>
        </ul>
      </article>
      <article>
        <h3>SensorManager</h3>
        <pre>
          <code class="java"><![CDATA[
                    SensorManager sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
                ]]></code>
        </pre>
        <p>Depuis SensorManager on peut lister les sensors présent dans le téléphone.</p>
        <pre>
          <code class="java"><![CDATA[
                    List<Sensor> sensors = sensorManager.getSensorList(Sensor.TYPE_ALL);
                    for (Sensor sensor : sensors) {
                        Log.d("debug_app", "sensor: " + sensor.getName());
                        Log.d("debug_app", "sensor: " + sensor.getMinDelay());
                        Log.d("debug_app", "sensor: " + sensor.getVersion());
                        Log.d("debug_app", "sensor: " + sensor.getMaximumRange());
                    }
                ]]></code>
        </pre>
      </article>
      <article>
        <h3>Sensor</h3>
        <p>La première chose s'est de vérifier si le sensor que l'on veut utiliser existe. Pour cela on va essayer de le
            récupérer depuis le sensorManager. On fait généralement cela dans onCreate.
        </p>
        <pre>
          <code class="java"><![CDATA[
                    Sensor sensorLight = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
                    if(sensorLight != null){
                        // sensor existe
                    } else {
                        // prévenir l'utilisateur qu'on ne peut pas continuer
                    }
                ]]></code>
        </pre>
        <p>
          Pour connaitre la constante 
          <kbd>Sensor.TYPE_LIGHT</kbd>
           qui correspond au sensor que l'on veut, il faut
            aller
            voir dans la 
          <a href="https://developer.android.com/guide/topics/sensors/sensors_overview">DOC</a>
          .
        
        </p>
        <img class="img-fluid rounded" src="../asset/sensor_type_doc.png" alt=""/>
        <p>Méthodes utiles :</p>
        <ul>
          <li>getResolution()</li>
          <li>getMaximumRange()</li>
          <li>getPower()</li>
        </ul>
      </article>
      <article>
        <h3>Listener</h3>
        <p>Pour lire les données provenant des Sensor il faut implementer deux méthodes de l'interface
            SensorEventListener. Elles sont appelées par le système.
        </p>
        <ul>
          <li>onAccuracyChanged() : lorsque la précision du sensor change (SENSOR_STATUS_ACCURACY_LOW,
                SENSOR_STATUS_ACCURACY_MEDIUM, SENSOR_STATUS_ACCURACY_HIGH, or SENSOR_STATUS_UNRELIABLE)
            </li>
          <li>onSensorChanged() : à chaque fois que les données du sensor changent. On va les retrouver dans
                SensorEvent
            </li>
        </ul>
        <pre>
          <code class="java"><![CDATA[
                SensorEventListener sensorEventListener = new SensorEventListener() {
                    @Override
                    public void onSensorChanged(SensorEvent event) {
                    }
                    @Override
                    public void onAccuracyChanged(Sensor sensor, int accuracy) {
                    }
                };
                ]]></code>
        </pre>
        <p>On aurait aussi pu utiliser implement dans l'activité ou la class qui nous arrange</p>
        <p>Pour enregistrer le listener on le fait dans onResume sur l'objet sensorManager et va préciser le délai
            d'écoute du sensor.
        </p>
        <ul>
          <li>SENSOR_DELAY_GAME (20,000 microsecondes délai)</li>
          <li>SENSOR_DELAY_UI (60,000 microsecondes délai)</li>
          <li>SENSOR_DELAY_FASTEST (0 microseconde délai)</li>
          <li>Depuis Android 3.0 spécifier la valeur en microseconde</li>
        </ul>
        <p>On fait ça dans onResume, car si on quitte l'activité et qu'on revient dessus onResume est appelé dans tous
            les cas.
        </p>
        <pre>
          <code class="java"><![CDATA[
                    @Override
                    protected void onResume() {
                        super.onResume();
                        sensorManager.registerListener(sensorEventListener, sensorLight, SensorManager.SENSOR_DELAY_FASTEST);
                    }
                ]]></code>
        </pre>
        <p>Lorsque l'on quitte l'activité et qu'elle passe en pause, il faut arrêter d'écouter le sensor. Écouter les
            sensors est une étape qui consomme beaucoup de batterie. Donc, il est important quand on quitte l'activité
            d'arrêter d'écouter le sensor.
        </p>
        <pre>
          <code class="java"><![CDATA[
                    @Override
                    protected void onPause() {
                        super.onPause();
                        sensorManager.unregisterListener(sensorEventListener,sensorLight);
                    }
                ]]></code>
        </pre>
      </article>
      <article>
        <h3>Traiter les valeurs</h3>
        <p>
          Tout va se passer dans onSensorChanged(SensorEvent event), les données vont être ajoutées dans l'objet
            SensorEvent. Plus précisément dans 
          <kbd>event.values</kbd>
          .
        
        </p>
        <p>values est un tableau de float qui va contenir la ou les valeurs du sensor.</p>
        <p>
          Il faut maintenant savoir combien de donnée on a pour le sensor. Ici encore c'est la 
          <a href="https://developer.android.com/guide/topics/sensors/sensors_environment">DOC
        </a>
           qui va nous donner l'information.
        
        </p>
        <img class="img-fluid rounded" src="../asset/sensor_value_doc.png" alt=""/>
        <p>Dans notre cas il n'y a qu'une seule valeur, mais si on regarde le magnétomètre, c'est différent.</p>
        <img class="img-fluid rounded" src="../asset/sensor_value_doc2.png" alt="" data-title="" data-subtitle=""/>
        <p>Si on veut afficher la valeur du luxmètre (mesure de la lumière) en lux (unité de mesure de la lumière) dans
            un TextView, voici le code
        </p>
        <pre>
          <code class="java"><![CDATA[
                    public class SensorActivity extends AppCompatActivity {
                        TextView textView;
                        SensorManager sensorManager;
                        SensorEventListener sensorEventListener;
                        Sensor sensorLight;
                        @Override
                        protected void onCreate(Bundle savedInstanceState) {
                            super.onCreate(savedInstanceState);
                            setContentView(R.layout.activity_sensor);
                            textView = findViewById(R.id.text);
                            sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
                            sensorLight = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
                            sensorEventListener = new SensorEventListener() {
                                @Override
                                public void onSensorChanged(SensorEvent event) {
                                    float luxValue = event.values[0];
                                    textView.setText(String.valueOf(luxValue) + " lux");
                                }
                                @Override
                                public void onAccuracyChanged(Sensor sensor, int accuracy) {
                                }
                            };
                        }
                        @Override
                        protected void onResume() {
                            super.onResume();
                            sensorManager.registerListener(sensorEventListener, sensorLight, SensorManager.SENSOR_DELAY_FASTEST);
                        }
                        @Override
                        protected void onPause() {
                            super.onPause();
                            sensorManager.unregisterListener(sensorEventListener,sensorLight);
                        }
                    }
                ]]></code>
        </pre>
        <p>
          L'avantage ici, c'est qu'il y a qu'une façon d'accéder à tous les sensors. Seul le nombre de valeurs dans le
            tableau 
          <kbd>event.values</kbd>
           va changer.
        
        </p>
      </article>
      <article>
        <h3>permissions</h3>
        <p>
          Si vous publiez votre application sur Google Play, vous pouvez utiliser l'élément
            
          <![CDATA[ <uses-feature> ]]>
          
            dans votre fichier manifeste pour filtrer votre application des appareils qui n'ont pas la configuration de
            capteur appropriée pour votre application.
        
        </p>
        <pre>
          <code class="xml"><![CDATA[
                    <uses-feature android:name="android.hardware.sensor.accelerometer"
                                  android:required="true" />
                ]]></code>
        </pre>
      </article>
    </section>
    <section>
      <h1>Utilisation de processus en arrière-plan</h1>
      <!--TODO thread-->
    </section>
    <section>
      <h1>Utiliser le protocole http</h1>
      <!--TODO http-->
    </section>
  </body>
</html>